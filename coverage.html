
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>parcat: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vegasq/parcat/cmd/parcat/main.go (13.6%)</option>
				
				<option value="file1">github.com/vegasq/parcat/output/csv.go (82.9%)</option>
				
				<option value="file2">github.com/vegasq/parcat/output/json.go (85.7%)</option>
				
				<option value="file3">github.com/vegasq/parcat/query/aggregate.go (79.3%)</option>
				
				<option value="file4">github.com/vegasq/parcat/query/executor.go (83.5%)</option>
				
				<option value="file5">github.com/vegasq/parcat/query/filter.go (75.4%)</option>
				
				<option value="file6">github.com/vegasq/parcat/query/function.go (71.9%)</option>
				
				<option value="file7">github.com/vegasq/parcat/query/lexer.go (92.9%)</option>
				
				<option value="file8">github.com/vegasq/parcat/query/parser.go (79.5%)</option>
				
				<option value="file9">github.com/vegasq/parcat/query/types.go (80.6%)</option>
				
				<option value="file10">github.com/vegasq/parcat/query/validation.go (70.0%)</option>
				
				<option value="file11">github.com/vegasq/parcat/query/window.go (79.3%)</option>
				
				<option value="file12">github.com/vegasq/parcat/reader/parquet.go (82.3%)</option>
				
				<option value="file13">github.com/vegasq/parcat/reader/schema.go (72.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/vegasq/parcat/output"
        "github.com/vegasq/parcat/query"
        "github.com/vegasq/parcat/reader"
)

var (
        queryFlag  = flag.String("q", "", "SQL query (e.g., \"select * from file.parquet where age &gt; 30\")")
        formatFlag = flag.String("f", "jsonl", "Output format: json, jsonl, csv")
        limitFlag  = flag.Int("limit", 0, "Limit number of rows (0 = unlimited)")
        schemaFlag = flag.Bool("schema", false, "Show schema information instead of data")
)

func main() <span class="cov0" title="0">{
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s [options] &lt;file.parquet&gt;\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "A tool to read and query Parquet files.\n\n")
                fmt.Fprintf(os.Stderr, "IMPORTANT: All flags must come BEFORE file arguments.\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  %s data.parquet\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -f csv data.parquet\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -q \"select * from data.parquet where age &gt; 30\" data.parquet\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s --schema data.parquet\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -f csv --schema data.parquet\n", os.Args[0])
        }</span>

        <span class="cov0" title="0">flag.Parse()

        // Validate flag values
        if *limitFlag &lt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -limit must be non-negative, got %d\n", *limitFlag)
                os.Exit(1)
        }</span>

        // Validate flag combinations
        <span class="cov0" title="0">if *schemaFlag &amp;&amp; *queryFlag != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: --schema and -q cannot be used together\n")
                os.Exit(1)
        }</span>

        // Get filename from positional args (optional if query has FROM clause)
        <span class="cov0" title="0">var filename string
        if flag.NArg() &gt;= 1 </span><span class="cov0" title="0">{
                filename = flag.Arg(0)
        }</span>

        // Handle schema mode
        <span class="cov0" title="0">if *schemaFlag </span><span class="cov0" title="0">{
                if filename == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: missing parquet file argument\n\n")
                        flag.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">handleSchemaMode(filename, *formatFlag)
                os.Exit(0)</span>
        }

        // Parse query if specified to determine if we need a filename
        <span class="cov0" title="0">var q *query.Query
        if *queryFlag != "" </span><span class="cov0" title="0">{
                var err error
                q, err = query.Parse(*queryFlag)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error parsing query: %v\n\n", err)
                        fmt.Fprintf(os.Stderr, "Query format: select * from file.parquet where &lt;condition&gt;\n")
                        fmt.Fprintf(os.Stderr, "Example: select * from data.parquet where age &gt; 30\n")
                        os.Exit(1)
                }</span>

                // If query specifies table name, use it instead of positional arg
                <span class="cov0" title="0">if q.TableName != "" &amp;&amp; filename == "" </span><span class="cov0" title="0">{
                        filename = q.TableName
                }</span>
        }

        // Declare rows variable before conditional logic
        <span class="cov0" title="0">var rows []map[string]interface{}
        var err error

        // Materialize CTEs FIRST (before loading main table) as they may be referenced in FROM
        ctx := query.NewExecutionContext(nil)
        if q != nil &amp;&amp; len(q.CTEs) &gt; 0 </span><span class="cov0" title="0">{
                // Use the executor's CTE materialization logic which includes circular dependency detection
                if err := ctx.MaterializeCTEs(q.CTEs, executeCTEQuery); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error materializing CTEs: %v\n", err)
                        os.Exit(1)
                }</span>
        }

        // Handle FROM subquery case
        <span class="cov0" title="0">if q != nil &amp;&amp; q.Subquery != nil </span><span class="cov0" title="0">{
                // Execute the subquery to get initial rows
                rows, err = executeCTEQuery(q.Subquery, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error executing FROM subquery: %v\n", err)
                        os.Exit(1)
                }</span>

                // Apply table alias if specified
                <span class="cov0" title="0">if q.TableAlias != "" </span><span class="cov0" title="0">{
                        rows = applyTableAliasHelper(rows, q.TableAlias)
                }</span>
        } else<span class="cov0" title="0"> if q != nil &amp;&amp; filename != "" &amp;&amp; len(ctx.CTEs) &gt; 0 </span><span class="cov0" title="0">{
                // Check if main table is a CTE reference
                if cteRows, exists := ctx.CTEs[q.TableName]; exists </span><span class="cov0" title="0">{
                        rows = cteRows
                        // Apply table alias if specified
                        if q.TableAlias != "" </span><span class="cov0" title="0">{
                                rows = applyTableAliasHelper(rows, q.TableAlias)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Not a CTE, read from file
                        rows, err = reader.ReadMultipleFiles(filename)
                        if err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Error: file '%s' not found\n", filename)
                                        fmt.Fprintf(os.Stderr, "Please check the file path and try again.\n")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }
                        // Apply table alias if specified
                        <span class="cov0" title="0">if q.TableAlias != "" </span><span class="cov0" title="0">{
                                rows = applyTableAliasHelper(rows, q.TableAlias)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Ensure we have a filename
                if filename == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: missing parquet file argument\n\n")
                        flag.Usage()
                        os.Exit(1)
                }</span>

                // Read all rows (supports glob patterns)
                <span class="cov0" title="0">rows, err = reader.ReadMultipleFiles(filename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error: file '%s' not found\n", filename)
                                fmt.Fprintf(os.Stderr, "Please check the file path and try again.\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">os.Exit(1)</span>
                }
                // Apply table alias if specified
                <span class="cov0" title="0">if q != nil &amp;&amp; q.TableAlias != "" </span><span class="cov0" title="0">{
                        rows = applyTableAliasHelper(rows, q.TableAlias)
                }</span>
        }

        // Apply query if specified
        <span class="cov0" title="0">if q != nil </span><span class="cov0" title="0">{
                // CTEs already materialized above in ctx
                // Table alias already applied in the paths above

                // Handle JOINs - need to read additional files
                if len(q.Joins) &gt; 0 </span><span class="cov0" title="0">{

                        // Execute JOINs
                        for _, join := range q.Joins </span><span class="cov0" title="0">{
                                var joinRows []map[string]interface{}

                                if join.Subquery != nil </span><span class="cov0" title="0">{
                                        // JOIN with subquery
                                        joinRows, err = executeCTEQuery(join.Subquery, ctx)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Fprintf(os.Stderr, "Error executing JOIN subquery: %v\n", err)
                                                os.Exit(1)
                                        }</span>
                                } else<span class="cov0" title="0"> if join.TableName != "" </span><span class="cov0" title="0">{
                                        // Check if it's a CTE reference
                                        if cteRows, exists := ctx.CTEs[join.TableName]; exists </span><span class="cov0" title="0">{
                                                joinRows = cteRows
                                        }</span> else<span class="cov0" title="0"> if ctx.AllCTENames[join.TableName] </span><span class="cov0" title="0">{
                                                // This is a forward CTE reference (CTE defined but not yet materialized)
                                                fmt.Fprintf(os.Stderr, "Error: forward CTE reference in JOIN: %s is defined but not yet materialized (CTEs must be referenced in order)\n", join.TableName)
                                                os.Exit(1)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Read from parquet file (supports glob)
                                                joinRows, err = reader.ReadMultipleFiles(join.TableName)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        fmt.Fprintf(os.Stderr, "Error reading JOIN table %s: %v\n", join.TableName, err)
                                                        os.Exit(1)
                                                }</span>
                                        }
                                }

                                // Apply alias to joined table if specified
                                <span class="cov0" title="0">if join.Alias != "" </span><span class="cov0" title="0">{
                                        joinRows = applyTableAliasHelper(joinRows, join.Alias)
                                }</span>

                                // Execute the join
                                <span class="cov0" title="0">rows, err = executeJoinHelper(rows, joinRows, join)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Error executing JOIN: %v\n", err)
                                        os.Exit(1)
                                }</span>
                        }
                }

                // Apply WHERE filter first (with context for subquery support)
                <span class="cov0" title="0">if q.Filter != nil </span><span class="cov0" title="0">{
                        rows, err = query.ApplyFilterWithContext(rows, q.Filter, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying filter: %v\n", err)
                                // List available columns to help user
                                if len(rows) &gt; 0 </span><span class="cov0" title="0">{
                                        columns := query.GetColumnNames(rows)
                                        fmt.Fprintf(os.Stderr, "\nAvailable columns: ")
                                        for i, col := range columns </span><span class="cov0" title="0">{
                                                if i &gt; 0 </span><span class="cov0" title="0">{
                                                        fmt.Fprintf(os.Stderr, ", ")
                                                }</span>
                                                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "%s", col)</span>
                                        }
                                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "\n")</span>
                                }
                                <span class="cov0" title="0">os.Exit(1)</span>
                        }
                }

                // Apply window functions if present (before aggregation and projection)
                <span class="cov0" title="0">hasWindowFunc := query.HasWindowFunction(q.SelectList)
                if hasWindowFunc </span><span class="cov0" title="0">{
                        rows, err = query.ApplyWindowFunctions(rows, q.SelectList)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying window functions: %v\n", err)
                                os.Exit(1)
                        }</span>
                        // After window functions, we need final projection but must not re-evaluate window exprs
                        // ApplyWindowFunctions already added window results as columns
                        // Now project to final SELECT list, treating window exprs as column references
                        <span class="cov0" title="0">rows, err = query.ApplySelectListAfterWindows(rows, q.SelectList)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying select list after windows: %v\n", err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> if len(q.GroupBy) &gt; 0 || query.HasAggregateFunction(q.SelectList) </span><span class="cov0" title="0">{
                        // Apply GROUP BY and aggregation if present
                        rows, err = query.ApplyGroupByAndAggregate(rows, q.GroupBy, q.SelectList)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying aggregation: %v\n", err)
                                os.Exit(1)
                        }</span>

                        // Apply HAVING filter if present
                        <span class="cov0" title="0">if q.Having != nil </span><span class="cov0" title="0">{
                                rows, err = query.EvaluateHaving(rows, q.Having)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Error applying HAVING clause: %v\n", err)
                                        os.Exit(1)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Apply SELECT list projection (only if no aggregation or windows) with context for scalar subquery support
                        if len(q.SelectList) &gt; 0 </span><span class="cov0" title="0">{
                                rows, err = query.ApplySelectListWithContext(rows, q.SelectList, ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Error applying select list: %v\n", err)
                                        os.Exit(1)
                                }</span>
                        }
                }

                // Apply DISTINCT if present
                <span class="cov0" title="0">if q.Distinct </span><span class="cov0" title="0">{
                        rows, err = query.ApplyDistinct(rows)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying DISTINCT: %v\n", err)
                                os.Exit(1)
                        }</span>
                }

                // Apply ORDER BY if present
                <span class="cov0" title="0">if len(q.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                        rows, err = query.ApplyOrderBy(rows, q.OrderBy)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying ORDER BY: %v\n", err)
                                os.Exit(1)
                        }</span>
                }

                // Apply SQL LIMIT and OFFSET if present
                <span class="cov0" title="0">if q.Limit != nil || q.Offset != nil </span><span class="cov0" title="0">{
                        rows, err = query.ApplyLimitOffset(rows, q.Limit, q.Offset)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error applying LIMIT/OFFSET: %v\n", err)
                                os.Exit(1)
                        }</span>
                }
        }

        // Apply flag-based limit only if SQL LIMIT was not specified
        <span class="cov0" title="0">if *limitFlag &gt; 0 &amp;&amp; (q == nil || q.Limit == nil) &amp;&amp; len(rows) &gt; *limitFlag </span><span class="cov0" title="0">{
                rows = rows[:*limitFlag]
        }</span>

        // Format and output
        <span class="cov0" title="0">var formatter output.Formatter
        switch *formatFlag </span>{
        case "json", "jsonl":<span class="cov0" title="0">
                formatter = output.NewJSONFormatter(os.Stdout)</span>
        case "csv":<span class="cov0" title="0">
                formatter = output.NewCSVFormatter(os.Stdout)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Error: unsupported format '%s'\n", *formatFlag)
                fmt.Fprintf(os.Stderr, "Supported formats: json, jsonl, csv\n")
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">if err := formatter.Format(rows); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error formatting output: %v\n", err)
                os.Exit(1)
        }</span>
}

// executeCTEQuery executes a CTE or subquery
func executeCTEQuery(q *query.Query, ctx *query.ExecutionContext) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var rows []map[string]interface{}
        var err error

        // Materialize any CTEs defined in this subquery FIRST
        // Use a child context to prevent CTE scope leaking to parent
        if len(q.CTEs) &gt; 0 </span><span class="cov0" title="0">{
                childCtx := ctx.NewChildContext()
                if err := childCtx.MaterializeCTEs(q.CTEs, executeCTEQuery); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to materialize CTEs in subquery: %w", err)
                }</span>
                // Use child context for the rest of this subquery
                <span class="cov0" title="0">ctx = childCtx</span>
        }

        // Handle subqueries in FROM clause
        <span class="cov0" title="0">if q.Subquery != nil </span><span class="cov0" title="0">{
                rows, err = executeCTEQuery(q.Subquery, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> if q.TableName != "" </span><span class="cov0" title="0">{
                // Check if this table is currently being materialized (circular dependency)
                if ctx.InProgress[q.TableName] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("circular CTE dependency detected: %s references itself", q.TableName)
                }</span>

                // Check if it's a CTE reference
                <span class="cov0" title="0">if cteRows, exists := ctx.CTEs[q.TableName]; exists </span><span class="cov0" title="0">{
                        rows = cteRows
                }</span> else<span class="cov0" title="0"> if ctx.AllCTENames[q.TableName] </span><span class="cov0" title="0">{
                        // This is a forward CTE reference (CTE defined but not yet materialized)
                        return nil, fmt.Errorf("forward CTE reference: %s is defined but not yet materialized (CTEs must be referenced in order)", q.TableName)
                }</span> else<span class="cov0" title="0"> {
                        // Read from parquet file
                        rows, err = reader.ReadMultipleFiles(q.TableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("no data source specified (table, CTE, or subquery)")
        }</span>

        // Apply table alias to main table rows if specified (BEFORE filtering/joins)
        <span class="cov0" title="0">if q.TableAlias != "" </span><span class="cov0" title="0">{
                rows = applyTableAliasHelper(rows, q.TableAlias)
        }</span>

        // Handle JOINs if present
        <span class="cov0" title="0">if len(q.Joins) &gt; 0 </span><span class="cov0" title="0">{
                for _, join := range q.Joins </span><span class="cov0" title="0">{
                        var joinRows []map[string]interface{}
                        if join.Subquery != nil </span><span class="cov0" title="0">{
                                joinRows, err = executeCTEQuery(join.Subquery, ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> if join.TableName != "" </span><span class="cov0" title="0">{
                                // Check for circular dependency
                                if ctx.InProgress[join.TableName] </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("circular CTE dependency detected: JOIN references %s which is currently being materialized", join.TableName)
                                }</span>

                                <span class="cov0" title="0">if cteRows, exists := ctx.CTEs[join.TableName]; exists </span><span class="cov0" title="0">{
                                        joinRows = cteRows
                                }</span> else<span class="cov0" title="0"> if ctx.AllCTENames[join.TableName] </span><span class="cov0" title="0">{
                                        // This is a forward CTE reference (CTE defined but not yet materialized)
                                        return nil, fmt.Errorf("forward CTE reference in JOIN: %s is defined but not yet materialized (CTEs must be referenced in order)", join.TableName)
                                }</span> else<span class="cov0" title="0"> {
                                        joinRows, err = reader.ReadMultipleFiles(join.TableName)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if join.Alias != "" </span><span class="cov0" title="0">{
                                joinRows = applyTableAliasHelper(joinRows, join.Alias)
                        }</span>

                        <span class="cov0" title="0">rows, err = executeJoinHelper(rows, joinRows, join)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        // Apply WHERE filter if present (with context for subquery support)
        <span class="cov0" title="0">if q.Filter != nil </span><span class="cov0" title="0">{
                rows, err = query.ApplyFilterWithContext(rows, q.Filter, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Apply window functions if present (before aggregation and projection)
        <span class="cov0" title="0">hasWindowFunc := query.HasWindowFunction(q.SelectList)
        if hasWindowFunc </span><span class="cov0" title="0">{
                rows, err = query.ApplyWindowFunctions(rows, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // After window functions, we need final projection but must not re-evaluate window exprs
                // ApplyWindowFunctions already added window results as columns
                // Now project to final SELECT list, treating window exprs as column references
                <span class="cov0" title="0">rows, err = query.ApplySelectListAfterWindows(rows, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> if len(q.GroupBy) &gt; 0 || query.HasAggregateFunction(q.SelectList) </span><span class="cov0" title="0">{
                // Apply GROUP BY and aggregation if present (BEFORE projection)
                rows, err = query.ApplyGroupByAndAggregate(rows, q.GroupBy, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Apply HAVING filter if present
                <span class="cov0" title="0">if q.Having != nil </span><span class="cov0" title="0">{
                        rows, err = query.EvaluateHaving(rows, q.Having)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Apply SELECT list projection (only if no aggregation or windows) with context for scalar subquery support
                if len(q.SelectList) &gt; 0 </span><span class="cov0" title="0">{
                        rows, err = query.ApplySelectListWithContext(rows, q.SelectList, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        // Apply DISTINCT if present
        <span class="cov0" title="0">if q.Distinct </span><span class="cov0" title="0">{
                rows, err = query.ApplyDistinct(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Apply ORDER BY if present
        <span class="cov0" title="0">if len(q.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = query.ApplyOrderBy(rows, q.OrderBy)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Apply LIMIT/OFFSET if present
        <span class="cov0" title="0">if q.Limit != nil || q.Offset != nil </span><span class="cov0" title="0">{
                rows, err = query.ApplyLimitOffset(rows, q.Limit, q.Offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return rows, nil</span>
}

// applyTableAliasHelper prefixes all column names with table alias
func applyTableAliasHelper(rows []map[string]interface{}, alias string) []map[string]interface{} <span class="cov8" title="1">{
        if alias == "" </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">aliasedRows := make([]map[string]interface{}, len(rows))
        for i, row := range rows </span><span class="cov8" title="1">{
                aliasedRow := make(map[string]interface{})
                for col, val := range row </span><span class="cov8" title="1">{
                        // Don't alias the special _file column
                        if col == "_file" </span><span class="cov8" title="1">{
                                aliasedRow[col] = val
                        }</span> else<span class="cov8" title="1"> {
                                aliasedRow[alias+"."+col] = val
                        }</span>
                }
                <span class="cov8" title="1">aliasedRows[i] = aliasedRow</span>
        }
        <span class="cov8" title="1">return aliasedRows</span>
}

// executeJoinHelper executes a JOIN operation
func executeJoinHelper(leftRows, rightRows []map[string]interface{}, join query.Join) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        switch join.Type </span>{
        case query.JoinInner:<span class="cov0" title="0">
                return executeInnerJoinHelper(leftRows, rightRows, join.Condition)</span>
        case query.JoinLeft:<span class="cov0" title="0">
                return executeLeftJoinHelper(leftRows, rightRows, join.Condition)</span>
        case query.JoinRight:<span class="cov0" title="0">
                return executeRightJoinHelper(leftRows, rightRows, join.Condition)</span>
        case query.JoinFull:<span class="cov0" title="0">
                return executeFullJoinHelper(leftRows, rightRows, join.Condition)</span>
        case query.JoinCross:<span class="cov0" title="0">
                return executeCrossJoinHelper(leftRows, rightRows)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported join type: %v", join.Type)</span>
        }
}

// executeInnerJoinHelper performs an INNER JOIN
func executeInnerJoinHelper(leftRows, rightRows []map[string]interface{}, condition query.Expression) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var result []map[string]interface{}

        for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                for _, rightRow := range rightRows </span><span class="cov0" title="0">{
                        // Merge rows
                        merged, err := mergeRowsHelper(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov0" title="0">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                result = append(result, merged)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeLeftJoinHelper performs a LEFT OUTER JOIN
func executeLeftJoinHelper(leftRows, rightRows []map[string]interface{}, condition query.Expression) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var result []map[string]interface{}

        // Special case: if right side is empty, return all left rows unchanged
        // (we can't add NULL columns without knowing the right side schema)
        if len(rightRows) == 0 </span><span class="cov0" title="0">{
                return append([]map[string]interface{}{}, leftRows...), nil
        }</span>

        <span class="cov0" title="0">for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                matched := false

                for _, rightRow := range rightRows </span><span class="cov0" title="0">{
                        // Merge rows
                        merged, err := mergeRowsHelper(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov0" title="0">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                result = append(result, merged)
                                matched = true
                        }</span>
                }

                // If no match, include left row with NULL values for right columns
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        merged, err := mergeRowsHelper(leftRow, createNullRowHelper(rightRows))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, merged)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeRightJoinHelper performs a RIGHT OUTER JOIN
func executeRightJoinHelper(leftRows, rightRows []map[string]interface{}, condition query.Expression) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var result []map[string]interface{}

        // Special case: if left side is empty, return all right rows unchanged
        // (we can't add NULL columns without knowing the left side schema)
        if len(leftRows) == 0 </span><span class="cov0" title="0">{
                return append([]map[string]interface{}{}, rightRows...), nil
        }</span>

        <span class="cov0" title="0">for _, rightRow := range rightRows </span><span class="cov0" title="0">{
                matched := false

                for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                        // Merge rows
                        merged, err := mergeRowsHelper(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov0" title="0">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                result = append(result, merged)
                                matched = true
                        }</span>
                }

                // If no match, include right row with NULL values for left columns
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        merged, err := mergeRowsHelper(createNullRowHelper(leftRows), rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, merged)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeFullJoinHelper performs a FULL OUTER JOIN
func executeFullJoinHelper(leftRows, rightRows []map[string]interface{}, condition query.Expression) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var result []map[string]interface{}

        // Special cases: if one side is empty, return the other side unchanged
        if len(leftRows) == 0 </span><span class="cov0" title="0">{
                return append([]map[string]interface{}{}, rightRows...), nil
        }</span>
        <span class="cov0" title="0">if len(rightRows) == 0 </span><span class="cov0" title="0">{
                return append([]map[string]interface{}{}, leftRows...), nil
        }</span>

        // Track which right rows have been matched
        <span class="cov0" title="0">rightMatched := make([]bool, len(rightRows))

        // Process left rows
        for _, leftRow := range leftRows </span><span class="cov0" title="0">{
                matched := false

                for i, rightRow := range rightRows </span><span class="cov0" title="0">{
                        // Merge rows
                        merged, err := mergeRowsHelper(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov0" title="0">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                result = append(result, merged)
                                matched = true
                                rightMatched[i] = true
                        }</span>
                }

                // If no match, include left row with NULL values for right columns
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        merged, err := mergeRowsHelper(leftRow, createNullRowHelper(rightRows))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, merged)</span>
                }
        }

        // Add unmatched right rows with NULL values for left columns
        <span class="cov0" title="0">for i, rightRow := range rightRows </span><span class="cov0" title="0">{
                if !rightMatched[i] </span><span class="cov0" title="0">{
                        merged, err := mergeRowsHelper(createNullRowHelper(leftRows), rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, merged)</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// executeCrossJoinHelper performs a CROSS JOIN (Cartesian product)
func executeCrossJoinHelper(leftRows, rightRows []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                for _, rightRow := range rightRows </span><span class="cov8" title="1">{
                        merged, err := mergeRowsHelper(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// mergeRowsHelper combines two rows into one
// If both left and right have the same column name, returns an error
func mergeRowsHelper(left, right map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        merged := make(map[string]interface{})

        // Copy left row
        for k, v := range left </span><span class="cov8" title="1">{
                merged[k] = v
        }</span>

        // Copy right row - check for collisions (except _file which is allowed to be duplicated)
        <span class="cov8" title="1">for k, v := range right </span><span class="cov8" title="1">{
                if _, exists := merged[k]; exists </span><span class="cov8" title="1">{
                        // Allow _file column to be duplicated - it's added by glob reads
                        // When both sides have _file, we keep both but suffix them with the table position
                        if k == "_file" </span><span class="cov8" title="1">{
                                // Keep left as _file_left and right as _file_right
                                if leftFile, ok := merged["_file"]; ok </span><span class="cov8" title="1">{
                                        delete(merged, "_file")
                                        merged["_file_left"] = leftFile
                                        merged["_file_right"] = v
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">return nil, fmt.Errorf("column name collision in JOIN: %q exists in both tables. Use table aliases to disambiguate (e.g., SELECT t1.%s, t2.%s FROM ...)", k, k, k)</span>
                }
                <span class="cov8" title="1">merged[k] = v</span>
        }

        <span class="cov8" title="1">return merged, nil</span>
}

// createNullRowHelper creates a row with NULL values for all columns from a sample row set.
// For empty row sets, we need to infer columns from the schema or accept that we cannot
// create proper NULL rows. In practice, this means OUTER JOINs with one empty side will
// not include NULL columns for that side - this is a known limitation when joining empty
// result sets without schema information.
func createNullRowHelper(rows []map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                // Cannot create NULL row without knowing column names
                // This is a limitation: outer joins with empty sides won't have NULL columns
                return make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">nullRow := make(map[string]interface{})
        // Use first row as template to get column names
        for col := range rows[0] </span><span class="cov8" title="1">{
                nullRow[col] = nil
        }</span>

        <span class="cov8" title="1">return nullRow</span>
}

// handleSchemaMode handles the --schema flag by extracting and displaying schema information
func handleSchemaMode(filename string, format string) <span class="cov8" title="1">{
        // Resolve filename - for glob patterns, use first match
        var filePath string

        // Check if pattern contains glob wildcards
        if strings.ContainsAny(filename, "*?[]{}") </span><span class="cov8" title="1">{
                matches, err := filepath.Glob(filename)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: invalid glob pattern: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: no files match pattern: %s\n", filename)
                        os.Exit(1)
                }</span>

                <span class="cov8" title="1">filePath = matches[0]
                // Print informational message to stderr
                if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "# Showing schema from: %s (%d files matched)\n", filePath, len(matches))
                }</span>
        } else<span class="cov8" title="1"> {
                filePath = filename
        }</span>

        // Extract schema information using reader package
        <span class="cov8" title="1">schemaInfos, err := reader.ExtractSchemaInfo(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: file '%s' not found\n", filePath)
                        fmt.Fprintf(os.Stderr, "Please check the file path and try again.\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Error opening file: %v\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        // Convert reader.SchemaInfo to []map[string]interface{} for formatter compatibility
        <span class="cov8" title="1">rows := make([]map[string]interface{}, len(schemaInfos))
        for i, field := range schemaInfos </span><span class="cov8" title="1">{
                rows[i] = map[string]interface{}{
                        "name":          field.Name,
                        "type":          field.Type,
                        "physical_type": field.PhysicalType,
                        "logical_type":  field.LogicalType,
                        "required":      field.Required,
                        "optional":      field.Optional,
                        "repeated":      field.Repeated,
                }
        }</span>

        // Format and output
        <span class="cov8" title="1">var formatter output.Formatter
        switch format </span>{
        case "json", "jsonl":<span class="cov8" title="1">
                formatter = output.NewJSONFormatter(os.Stdout)</span>
        case "csv":<span class="cov8" title="1">
                formatter = output.NewCSVFormatter(os.Stdout)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Error: unsupported format '%s'\n", format)
                fmt.Fprintf(os.Stderr, "Supported formats: json, jsonl, csv\n")
                os.Exit(1)</span>
        }

        <span class="cov8" title="1">if err := formatter.Format(rows); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error formatting output: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package output

import (
        "encoding/csv"
        "fmt"
        "io"
        "sort"
)

// CSVFormatter outputs rows as CSV format
type CSVFormatter struct {
        writer io.Writer
}

// NewCSVFormatter creates a new CSV formatter
func NewCSVFormatter(w io.Writer) *CSVFormatter <span class="cov8" title="1">{
        return &amp;CSVFormatter{writer: w}
}</span>

// SetOutput sets the output writer
func (c *CSVFormatter) SetOutput(w io.Writer) <span class="cov8" title="1">{
        c.writer = w
}</span>

// Format writes rows as CSV
func (c *CSVFormatter) Format(rows []map[string]interface{}) error <span class="cov8" title="1">{
        csvWriter := csv.NewWriter(c.writer)

        if len(rows) == 0 </span><span class="cov8" title="1">{
                csvWriter.Flush()
                if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to flush CSV writer: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Extract all unique column names from all rows (in case of heterogeneous schemas)
        // This handles cases like OUTER JOINs or sparse data where different rows may have different columns
        <span class="cov8" title="1">columnSet := make(map[string]bool)
        for _, row := range rows </span><span class="cov8" title="1">{
                for col := range row </span><span class="cov8" title="1">{
                        columnSet[col] = true
                }</span>
        }

        // Convert to sorted slice for consistent ordering
        <span class="cov8" title="1">columns := make([]string, 0, len(columnSet))
        for col := range columnSet </span><span class="cov8" title="1">{
                columns = append(columns, col)
        }</span>
        <span class="cov8" title="1">sort.Strings(columns)

        // Write header
        if err := csvWriter.Write(columns); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write rows
        <span class="cov8" title="1">for _, row := range rows </span><span class="cov8" title="1">{
                record := make([]string, len(columns))
                for i, col := range columns </span><span class="cov8" title="1">{
                        record[i] = formatValue(row[col])
                }</span>
                <span class="cov8" title="1">if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Flush and check for errors
        <span class="cov8" title="1">csvWriter.Flush()
        if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush CSV writer: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// formatValue converts a value to string for CSV output
func formatValue(v interface{}) string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                // Sanitize against CSV injection by prefixing dangerous characters
                // that could trigger formula execution in spreadsheet applications
                if len(val) &gt; 0 </span><span class="cov8" title="1">{
                        firstChar := val[0]
                        if firstChar == '=' || firstChar == '+' || firstChar == '-' || firstChar == '@' || firstChar == '\t' || firstChar == '\r' || firstChar == '\n' || firstChar == '|' </span><span class="cov0" title="0">{
                                return "'" + val
                        }</span>
                }
                <span class="cov8" title="1">return val</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", val)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", val)</span>
        case float32, float64:<span class="cov8" title="1">
                return fmt.Sprintf("%g", val)</span>
        case bool:<span class="cov8" title="1">
                return fmt.Sprintf("%t", val)</span>
        default:<span class="cov0" title="0">
                // For complex types, use JSON representation
                return fmt.Sprintf("%v", val)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package output

import (
        "encoding/json"
        "io"
)

// JSONFormatter outputs rows as JSON Lines format
type JSONFormatter struct {
        writer io.Writer
}

// NewJSONFormatter creates a new JSON Lines formatter
func NewJSONFormatter(w io.Writer) *JSONFormatter <span class="cov8" title="1">{
        return &amp;JSONFormatter{writer: w}
}</span>

// SetOutput sets the output writer
func (j *JSONFormatter) SetOutput(w io.Writer) <span class="cov8" title="1">{
        j.writer = w
}</span>

// Format writes rows as JSON Lines (one JSON object per line)
func (j *JSONFormatter) Format(rows []map[string]interface{}) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(j.writer)
        for _, row := range rows </span><span class="cov8" title="1">{
                if err := encoder.Encode(row); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package query

import (
        "fmt"
        "math"
        "strings"
)

// Group represents a group of rows for aggregation
type Group struct {
        Key    string                   // Hash key for the group
        Values map[string]interface{}   // Column values for GROUP BY columns
        Rows   []map[string]interface{} // All rows in the group
}

// ApplyGroupByAndAggregate applies GROUP BY and aggregation to rows
func ApplyGroupByAndAggregate(rows []map[string]interface{}, groupByColumns []string, selectList []SelectItem) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        // Validate SELECT list before aggregation
        if err := validateSelectListWithGroupBy(selectList, groupByColumns); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If no GROUP BY, treat all rows as one group (for aggregates without GROUP BY)
        // This should return one aggregate row even when input is empty (e.g., COUNT(*) = 0)
        <span class="cov8" title="1">if len(groupByColumns) == 0 </span><span class="cov8" title="1">{
                return aggregateWithoutGroupBy(rows, selectList)
        }</span>

        // For GROUP BY queries, empty input returns empty output
        <span class="cov8" title="1">if len(rows) == 0 </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        // Hash-based grouping
        <span class="cov8" title="1">groups := make(map[string]*Group)

        for _, row := range rows </span><span class="cov8" title="1">{
                // Compute group key from GROUP BY columns
                key, groupValues, err := computeGroupKey(row, groupByColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Add row to group
                <span class="cov8" title="1">if group, exists := groups[key]; exists </span><span class="cov8" title="1">{
                        group.Rows = append(group.Rows, row)
                }</span> else<span class="cov8" title="1"> {
                        groups[key] = &amp;Group{
                                Key:    key,
                                Values: groupValues,
                                Rows:   []map[string]interface{}{row},
                        }
                }</span>
        }

        // Compute aggregates for each group
        <span class="cov8" title="1">result := make([]map[string]interface{}, 0, len(groups))
        for _, group := range groups </span><span class="cov8" title="1">{
                aggregatedRow, err := computeAggregates(group, selectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, aggregatedRow)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// computeGroupKey computes a hash key for a group based on GROUP BY columns
func computeGroupKey(row map[string]interface{}, groupByColumns []string) (string, map[string]interface{}, error) <span class="cov8" title="1">{
        var keyBuilder strings.Builder
        groupValues := make(map[string]interface{})

        for i, col := range groupByColumns </span><span class="cov8" title="1">{
                value, exists := row[col]
                if !exists </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("GROUP BY column %q not found in row", col)
                }</span>

                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov8" title="1">{
                        keyBuilder.WriteString("\x00||\x00") // Use unlikely separator to avoid collisions
                }</span>
                // Include column name in key to prevent cross-column collisions
                <span class="cov8" title="1">keyBuilder.WriteString(col)
                keyBuilder.WriteString("\x00:\x00")
                keyBuilder.WriteString(fmt.Sprintf("%#v", value)) // Use %#v for better type differentiation
                groupValues[col] = value</span>
        }

        <span class="cov8" title="1">return keyBuilder.String(), groupValues, nil</span>
}

// aggregateWithoutGroupBy handles aggregation without GROUP BY (all rows as one group)
func aggregateWithoutGroupBy(rows []map[string]interface{}, selectList []SelectItem) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        group := &amp;Group{
                Key:    "",
                Values: make(map[string]interface{}),
                Rows:   rows,
        }

        aggregatedRow, err := computeAggregates(group, selectList)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []map[string]interface{}{aggregatedRow}, nil</span>
}

// computeAggregates computes aggregate values for a group
func computeAggregates(group *Group, selectList []SelectItem) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        // Compute each SELECT item
        // Note: GROUP BY columns are only included if explicitly selected
        for _, item := range selectList </span><span class="cov8" title="1">{
                var value interface{}
                var err error

                // Check if it's an aggregate expression
                if aggExpr, ok := item.Expr.(*AggregateExpr); ok </span><span class="cov8" title="1">{
                        value, err = evaluateAggregate(aggExpr, group.Rows)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> if colRef, ok := item.Expr.(*ColumnRef); ok </span><span class="cov8" title="1">{
                        // For non-aggregate columns, use the value from the first row in the group
                        // (should be the same for all rows in the group if it's a GROUP BY column)
                        if len(group.Rows) == 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("column %q not found in empty group", colRef.Column)
                        }</span>
                        <span class="cov8" title="1">val, exists := group.Rows[0][colRef.Column]
                        if !exists </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("column %q not found", colRef.Column)
                        }</span>
                        <span class="cov8" title="1">value = val</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("non-aggregate expression in SELECT with GROUP BY is not supported")
                }</span>

                // Determine column name
                <span class="cov8" title="1">columnName := item.Alias
                if columnName == "" </span><span class="cov8" title="1">{
                        if aggExpr, ok := item.Expr.(*AggregateExpr); ok </span><span class="cov8" title="1">{
                                columnName = strings.ToLower(aggExpr.Function)
                        }</span> else<span class="cov8" title="1"> if colRef, ok := item.Expr.(*ColumnRef); ok </span><span class="cov8" title="1">{
                                columnName = colRef.Column
                        }</span> else<span class="cov0" title="0"> {
                                columnName = fmt.Sprintf("col_%d", len(result))
                        }</span>
                }

                <span class="cov8" title="1">result[columnName] = value</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// evaluateAggregate evaluates an aggregate function over a set of rows
func evaluateAggregate(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch aggExpr.Function </span>{
        case "COUNT":<span class="cov8" title="1">
                return evaluateCount(aggExpr, rows)</span>
        case "SUM":<span class="cov8" title="1">
                return evaluateSum(aggExpr, rows)</span>
        case "AVG":<span class="cov8" title="1">
                return evaluateAvg(aggExpr, rows)</span>
        case "MIN":<span class="cov8" title="1">
                return evaluateMin(aggExpr, rows)</span>
        case "MAX":<span class="cov8" title="1">
                return evaluateMax(aggExpr, rows)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown aggregate function: %s", aggExpr.Function)</span>
        }
}

// evaluateCount evaluates COUNT aggregate
func evaluateCount(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // COUNT(*) counts all rows
        if aggExpr.Arg == nil </span><span class="cov8" title="1">{
                return int64(len(rows)), nil
        }</span>

        // COUNT(column) counts non-null values
        <span class="cov8" title="1">count := int64(0)
        for _, row := range rows </span><span class="cov8" title="1">{
                value, err := aggExpr.Arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip rows where column doesn't exist or errors
                        continue</span>
                }
                <span class="cov8" title="1">if value != nil </span><span class="cov8" title="1">{
                        count++
                }</span>
        }

        <span class="cov8" title="1">return count, nil</span>
}

// evaluateSum evaluates SUM aggregate
func evaluateSum(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if aggExpr.Arg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUM requires an argument")
        }</span>

        <span class="cov8" title="1">sum := 0.0
        hasValues := false

        for _, row := range rows </span><span class="cov8" title="1">{
                value, err := aggExpr.Arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">num, err := valueToNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SUM: %w", err)
                }</span>

                <span class="cov8" title="1">sum += num
                hasValues = true</span>
        }

        <span class="cov8" title="1">if !hasValues </span><span class="cov0" title="0">{
                return nil, nil // Return NULL if no values
        }</span>

        <span class="cov8" title="1">return sum, nil</span>
}

// evaluateAvg evaluates AVG aggregate
func evaluateAvg(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if aggExpr.Arg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AVG requires an argument")
        }</span>

        <span class="cov8" title="1">sum := 0.0
        count := int64(0)

        for _, row := range rows </span><span class="cov8" title="1">{
                value, err := aggExpr.Arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">num, err := valueToNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("AVG: %w", err)
                }</span>

                <span class="cov8" title="1">sum += num
                count++</span>
        }

        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return nil, nil // Return NULL if no values
        }</span>

        <span class="cov8" title="1">return sum / float64(count), nil</span>
}

// evaluateMin evaluates MIN aggregate
func evaluateMin(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if aggExpr.Arg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MIN requires an argument")
        }</span>

        <span class="cov8" title="1">var min *float64

        for _, row := range rows </span><span class="cov8" title="1">{
                value, err := aggExpr.Arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">num, err := valueToNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MIN: %w", err)
                }</span>

                <span class="cov8" title="1">if min == nil || num &lt; *min </span><span class="cov8" title="1">{
                        min = &amp;num
                }</span>
        }

        <span class="cov8" title="1">if min == nil </span><span class="cov0" title="0">{
                return nil, nil // Return NULL if no values
        }</span>

        <span class="cov8" title="1">return *min, nil</span>
}

// evaluateMax evaluates MAX aggregate
func evaluateMax(aggExpr *AggregateExpr, rows []map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if aggExpr.Arg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MAX requires an argument")
        }</span>

        <span class="cov8" title="1">var max *float64

        for _, row := range rows </span><span class="cov8" title="1">{
                value, err := aggExpr.Arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">num, err := valueToNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("MAX: %w", err)
                }</span>

                <span class="cov8" title="1">if max == nil || num &gt; *max </span><span class="cov8" title="1">{
                        max = &amp;num
                }</span>
        }

        <span class="cov8" title="1">if max == nil </span><span class="cov0" title="0">{
                return nil, nil // Return NULL if no values
        }</span>

        <span class="cov8" title="1">return *max, nil</span>
}

// EvaluateHaving evaluates the HAVING clause on aggregated rows
func EvaluateHaving(rows []map[string]interface{}, having Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if having == nil </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        <span class="cov8" title="1">filtered := make([]map[string]interface{}, 0)
        for _, row := range rows </span><span class="cov8" title="1">{
                match, err := having.Evaluate(row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("HAVING: %w", err)
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        filtered = append(filtered, row)
                }</span>
        }

        <span class="cov8" title="1">return filtered, nil</span>
}

// hasAggregateFunction checks if the SELECT list contains any aggregate functions
func HasAggregateFunction(selectList []SelectItem) bool <span class="cov8" title="1">{
        for _, item := range selectList </span><span class="cov8" title="1">{
                if _, ok := item.Expr.(*AggregateExpr); ok </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// validateSelectListWithGroupBy validates that non-aggregate columns in SELECT are in GROUP BY
func validateSelectListWithGroupBy(selectList []SelectItem, groupByColumns []string) error <span class="cov8" title="1">{
        // Build map of GROUP BY columns for fast lookup
        groupByMap := make(map[string]bool)
        for _, col := range groupByColumns </span><span class="cov8" title="1">{
                groupByMap[col] = true
        }</span>

        // Check if there are any aggregate functions
        <span class="cov8" title="1">hasAggregates := HasAggregateFunction(selectList)

        for _, item := range selectList </span><span class="cov8" title="1">{
                // Skip aggregate expressions - they are valid with or without GROUP BY
                if _, ok := item.Expr.(*AggregateExpr); ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                // For non-aggregate column references
                <span class="cov8" title="1">if colRef, ok := item.Expr.(*ColumnRef); ok </span><span class="cov8" title="1">{
                        // If there are aggregates but no GROUP BY, non-aggregate columns are not allowed
                        if hasAggregates &amp;&amp; len(groupByColumns) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("column %q must appear in GROUP BY clause or be used in an aggregate function", colRef.Column)
                        }</span>

                        // If there is a GROUP BY, non-aggregate columns must be in the GROUP BY list
                        <span class="cov8" title="1">if len(groupByColumns) &gt; 0 &amp;&amp; !groupByMap[colRef.Column] </span><span class="cov0" title="0">{
                                return fmt.Errorf("column %q must appear in GROUP BY clause or be used in an aggregate function", colRef.Column)
                        }</span>
                }
                // Other expression types (function calls, etc.) are handled elsewhere
        }

        <span class="cov8" title="1">return nil</span>
}

// init ensures math package is available
func init() <span class="cov8" title="1">{
        _ = math.Abs(0)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package query

import (
        "fmt"

        "github.com/vegasq/parcat/reader"
)

// ExecutionContext holds the context for query execution
type ExecutionContext struct {
        // CTEs maps CTE names to their materialized results
        CTEs map[string][]map[string]interface{}
        // Reader for reading parquet files
        Reader *reader.Reader
        // InProgress tracks CTEs currently being materialized (for circular dependency detection)
        InProgress map[string]bool
        // AllCTENames tracks all CTE names defined in the query (for forward reference detection)
        AllCTENames map[string]bool
        // ScalarSubqueryCache caches results of non-correlated scalar subqueries to avoid re-execution
        ScalarSubqueryCache map[*ScalarSubqueryExpr]interface{}
}

// NewExecutionContext creates a new execution context
func NewExecutionContext(r *reader.Reader) *ExecutionContext <span class="cov8" title="1">{
        return &amp;ExecutionContext{
                CTEs:                make(map[string][]map[string]interface{}),
                Reader:              r,
                InProgress:          make(map[string]bool),
                AllCTENames:         make(map[string]bool),
                ScalarSubqueryCache: make(map[*ScalarSubqueryExpr]interface{}),
        }
}</span>

// NewChildContext creates a child context for nested queries with isolated CTE scope
// but inheriting access to parent CTEs
func (ctx *ExecutionContext) NewChildContext() *ExecutionContext <span class="cov8" title="1">{
        child := &amp;ExecutionContext{
                CTEs:                make(map[string][]map[string]interface{}),
                Reader:              ctx.Reader,
                InProgress:          make(map[string]bool),
                AllCTENames:         make(map[string]bool),
                ScalarSubqueryCache: make(map[*ScalarSubqueryExpr]interface{}),
        }
        // Copy parent CTEs to make them accessible in child scope
        for name, rows := range ctx.CTEs </span><span class="cov8" title="1">{
                child.CTEs[name] = rows
        }</span>
        // Copy parent AllCTENames to enable forward-reference detection in child scope
        <span class="cov8" title="1">for name := range ctx.AllCTENames </span><span class="cov8" title="1">{
                child.AllCTENames[name] = true
        }</span>
        // Note: We don't copy ScalarSubqueryCache to child - each subquery context
        // should have its own cache since subquery results may differ in different contexts
        <span class="cov8" title="1">return child</span>
}

// ExecuteQuery executes a query with CTE support
func ExecuteQuery(q *Query, r *reader.Reader) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        ctx := NewExecutionContext(r)

        // Materialize CTEs first
        if len(q.CTEs) &gt; 0 </span><span class="cov8" title="1">{
                if err := ctx.materializeCTEs(q.CTEs); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to materialize CTEs: %w", err)
                }</span>
        }

        // Execute the main query
        <span class="cov8" title="1">return ctx.executeSelect(q)</span>
}

// materializeCTEs evaluates and materializes all CTEs
func (ctx *ExecutionContext) materializeCTEs(ctes []CTE) error <span class="cov8" title="1">{
        return ctx.MaterializeCTEs(ctes, func(q *Query, c *ExecutionContext) ([]map[string]interface{}, error) </span><span class="cov8" title="1">{
                return ctx.executeSelect(q)
        }</span>)
}

// MaterializeCTEs evaluates and materializes all CTEs with circular dependency detection
// The executeFn parameter allows callers to provide custom execution logic
func (ctx *ExecutionContext) MaterializeCTEs(ctes []CTE, executeFn func(*Query, *ExecutionContext) ([]map[string]interface{}, error)) error <span class="cov8" title="1">{
        // Track which CTEs are being defined in this batch to detect duplicates
        localCTENames := make(map[string]bool)

        // Build map of all CTE names for forward reference detection
        for _, cte := range ctes </span><span class="cov8" title="1">{
                // Check for duplicate in current batch (same WITH clause)
                if localCTENames[cte.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf("duplicate CTE name in same WITH clause: %s", cte.Name)
                }</span>
                <span class="cov8" title="1">localCTENames[cte.Name] = true
                ctx.AllCTENames[cte.Name] = true</span>
        }

        <span class="cov8" title="1">materialize := func(name string, query *Query) error </span><span class="cov8" title="1">{
                // Check for cycle using the context's InProgress map
                if ctx.InProgress[name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("circular CTE dependency detected: %s", name)
                }</span>

                // Mark as in progress before execution
                <span class="cov8" title="1">ctx.InProgress[name] = true
                defer func() </span><span class="cov8" title="1">{ delete(ctx.InProgress, name) }</span>()

                // Execute the CTE query using the provided executor function
                <span class="cov8" title="1">rows, err := executeFn(query, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute CTE %s: %w", name, err)
                }</span>

                // Store the materialized result (may shadow parent CTE - this is standard SQL behavior)
                <span class="cov8" title="1">ctx.CTEs[name] = rows
                return nil</span>
        }

        <span class="cov8" title="1">for _, cte := range ctes </span><span class="cov8" title="1">{
                if err := materialize(cte.Name, cte.Query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// executeSelect executes a SELECT query
func (ctx *ExecutionContext) executeSelect(q *Query) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var rows []map[string]interface{}
        var err error

        // Read data from source (table, CTE, or subquery)
        if q.Subquery != nil </span><span class="cov8" title="1">{
                // FROM subquery - use child context if subquery has CTEs to prevent scope leaking
                var subqueryCtx *ExecutionContext
                if len(q.Subquery.CTEs) &gt; 0 </span><span class="cov8" title="1">{
                        subqueryCtx = ctx.NewChildContext()
                        if err := subqueryCtx.materializeCTEs(q.Subquery.CTEs); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to materialize CTEs in subquery: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        subqueryCtx = ctx
                }</span>
                <span class="cov8" title="1">rows, err = subqueryCtx.executeSelect(q.Subquery)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute FROM subquery: %w", err)
                }</span>
        } else<span class="cov8" title="1"> if q.TableName != "" </span><span class="cov8" title="1">{
                // Check if it's a CTE reference
                if cteRows, exists := ctx.CTEs[q.TableName]; exists </span><span class="cov8" title="1">{
                        rows = cteRows
                }</span> else<span class="cov8" title="1"> if ctx.AllCTENames[q.TableName] </span><span class="cov8" title="1">{
                        // This is a forward CTE reference (CTE defined but not yet materialized)
                        return nil, fmt.Errorf("forward CTE reference: %s is defined but not yet materialized (CTEs must be referenced in order)", q.TableName)
                }</span> else<span class="cov8" title="1"> {
                        // Read from parquet file
                        rows, err = reader.ReadMultipleFiles(q.TableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read table %s: %w", q.TableName, err)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("no data source specified (table, CTE, or subquery)")
        }</span>

        // Apply table alias to main table rows if specified
        <span class="cov8" title="1">if q.TableAlias != "" </span><span class="cov8" title="1">{
                rows = applyTableAlias(rows, q.TableAlias)
        }</span>

        // Execute JOINs if present
        <span class="cov8" title="1">if len(q.Joins) &gt; 0 </span><span class="cov8" title="1">{
                for _, join := range q.Joins </span><span class="cov8" title="1">{
                        rows, err = ctx.executeJoin(rows, q.TableAlias, join)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to execute JOIN: %w", err)
                        }</span>
                }
        }

        // Apply WHERE filter
        <span class="cov8" title="1">if q.Filter != nil </span><span class="cov8" title="1">{
                // Check if filter contains subqueries and evaluate them
                rows, err = ctx.applyFilterWithSubqueries(rows, q.Filter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply filter: %w", err)
                }</span>
        }

        // Apply window functions if present (before aggregation and projection)
        <span class="cov8" title="1">hasWindowFunc := HasWindowFunction(q.SelectList)
        if hasWindowFunc </span><span class="cov0" title="0">{
                rows, err = ApplyWindowFunctions(rows, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply window functions: %w", err)
                }</span>
                // After window functions, we need final projection but must not re-evaluate window exprs
                // ApplyWindowFunctions already added window results as columns
                // Now project to final SELECT list, treating window exprs as column references
                <span class="cov0" title="0">rows, err = ApplySelectListAfterWindows(rows, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply select list after windows: %w", err)
                }</span>
        } else<span class="cov8" title="1"> if len(q.GroupBy) &gt; 0 || HasAggregateFunction(q.SelectList) </span><span class="cov8" title="1">{
                // Apply GROUP BY and aggregation if present (BEFORE projection)
                rows, err = ApplyGroupByAndAggregate(rows, q.GroupBy, q.SelectList)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply aggregation: %w", err)
                }</span>

                // Apply HAVING filter if present
                <span class="cov8" title="1">if q.Having != nil </span><span class="cov0" title="0">{
                        rows, err = EvaluateHaving(rows, q.Having)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to apply HAVING clause: %w", err)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Apply SELECT list projection (only if no aggregation or windows) with context for scalar subquery support
                if len(q.SelectList) &gt; 0 </span><span class="cov8" title="1">{
                        rows, err = ApplySelectListWithContext(rows, q.SelectList, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to apply select list: %w", err)
                        }</span>
                }
        }

        // Apply DISTINCT if present
        <span class="cov8" title="1">if q.Distinct </span><span class="cov0" title="0">{
                rows, err = ApplyDistinct(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply DISTINCT: %w", err)
                }</span>
        }

        // Apply ORDER BY if present
        <span class="cov8" title="1">if len(q.OrderBy) &gt; 0 </span><span class="cov0" title="0">{
                rows, err = ApplyOrderBy(rows, q.OrderBy)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply ORDER BY: %w", err)
                }</span>
        }

        // Apply LIMIT/OFFSET if present
        <span class="cov8" title="1">if q.Limit != nil || q.Offset != nil </span><span class="cov0" title="0">{
                rows, err = ApplyLimitOffset(rows, q.Limit, q.Offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply LIMIT/OFFSET: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return rows, nil</span>
}

// applyFilterWithSubqueries applies a filter expression with subquery support
func (ctx *ExecutionContext) applyFilterWithSubqueries(rows []map[string]interface{}, filter Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        for _, row := range rows </span><span class="cov8" title="1">{
                match, err := ctx.EvaluateExpression(row, filter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        result = append(result, row)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// EvaluateExpression evaluates an expression with subquery support
func (ctx *ExecutionContext) EvaluateExpression(row map[string]interface{}, expr Expression) (bool, error) <span class="cov8" title="1">{
        switch e := expr.(type) </span>{
        case *ExistsExpr:<span class="cov8" title="1">
                return ctx.evaluateExists(row, e)</span>
        case *InSubqueryExpr:<span class="cov8" title="1">
                return ctx.evaluateInSubquery(row, e)</span>
        case *BinaryExpr:<span class="cov8" title="1">
                // Recursively evaluate both sides with context to support nested subqueries
                left, err := ctx.EvaluateExpression(row, e.Left)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">right, err := ctx.EvaluateExpression(row, e.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">switch e.Operator </span>{
                case TokenAnd:<span class="cov8" title="1">
                        return left &amp;&amp; right, nil</span>
                case TokenOr:<span class="cov8" title="1">
                        return left || right, nil</span>
                default:<span class="cov8" title="1">
                        return false, fmt.Errorf("unsupported binary operator: %v", e.Operator)</span>
                }
        default:<span class="cov8" title="1">
                // Use the standard Evaluate method for non-subquery expressions
                return expr.Evaluate(row)</span>
        }
}

// evaluateExists evaluates an EXISTS expression
// NOTE: Correlated subqueries (subqueries that reference columns from outer query)
// are not currently supported. The subquery is executed independently without
// access to the outer row context.
func (ctx *ExecutionContext) evaluateExists(row map[string]interface{}, expr *ExistsExpr) (bool, error) <span class="cov8" title="1">{
        // Materialize subquery-local CTEs first if present
        var subqueryCtx *ExecutionContext
        if len(expr.Subquery.CTEs) &gt; 0 </span><span class="cov8" title="1">{
                subqueryCtx = ctx.NewChildContext()
                if err := subqueryCtx.materializeCTEs(expr.Subquery.CTEs); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("EXISTS subquery CTE materialization failed: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                subqueryCtx = ctx
        }</span>

        // Execute the subquery
        // TODO: Support correlated subqueries by passing outer row context
        <span class="cov8" title="1">rows, err := subqueryCtx.executeSelect(expr.Subquery)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("EXISTS subquery failed: %w", err)
        }</span>

        // EXISTS is true if subquery returns any rows
        <span class="cov8" title="1">exists := len(rows) &gt; 0

        // Apply negation if needed
        if expr.Negate </span><span class="cov8" title="1">{
                return !exists, nil
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

// evaluateInSubquery evaluates an IN subquery expression
// NOTE: Correlated subqueries (subqueries that reference columns from outer query)
// are not currently supported. The subquery is executed independently without
// access to the outer row context.
func (ctx *ExecutionContext) evaluateInSubquery(row map[string]interface{}, expr *InSubqueryExpr) (bool, error) <span class="cov8" title="1">{
        // Get the column value
        value, exists := row[expr.Column]
        if !exists </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Materialize subquery-local CTEs first if present
        <span class="cov8" title="1">var subqueryCtx *ExecutionContext
        if len(expr.Subquery.CTEs) &gt; 0 </span><span class="cov8" title="1">{
                subqueryCtx = ctx.NewChildContext()
                if err := subqueryCtx.materializeCTEs(expr.Subquery.CTEs); err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("IN subquery CTE materialization failed: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                subqueryCtx = ctx
        }</span>

        // Execute the subquery
        // TODO: Support correlated subqueries by passing outer row context
        <span class="cov8" title="1">rows, err := subqueryCtx.executeSelect(expr.Subquery)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("IN subquery failed: %w", err)
        }</span>

        // Check if the subquery returns exactly one column
        <span class="cov8" title="1">if len(rows) &gt; 0 </span><span class="cov8" title="1">{
                firstRow := rows[0]
                if len(firstRow) != 1 </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("IN subquery must return exactly one column, got %d", len(firstRow))
                }</span>
        }

        // Check if value is in the subquery results
        <span class="cov8" title="1">found := false
        for _, subRow := range rows </span><span class="cov8" title="1">{
                // Get the single column value from the subquery result
                var subValue interface{}
                for _, v := range subRow </span><span class="cov8" title="1">{
                        subValue = v
                        break</span>
                }

                // Compare values
                <span class="cov8" title="1">match, err := compare(value, TokenEqual, subValue)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }

        // Apply negation if needed
        <span class="cov8" title="1">if expr.Negate </span><span class="cov8" title="1">{
                return !found, nil
        }</span>
        <span class="cov8" title="1">return found, nil</span>
}

// EvaluateSelectExpression evaluates any SelectExpression with context support for nested subqueries
func (ctx *ExecutionContext) EvaluateSelectExpression(row map[string]interface{}, expr SelectExpression) (interface{}, error) <span class="cov8" title="1">{
        switch e := expr.(type) </span>{
        case *ScalarSubqueryExpr:<span class="cov8" title="1">
                return ctx.EvaluateScalarSubquery(row, e)</span>
        case *FunctionCall:<span class="cov8" title="1">
                // Look up the function in the registry
                registry := GetGlobalRegistry()
                fn, exists := registry.Get(e.Name)
                if !exists </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("unknown function: %s", e.Name)
                }</span>

                // Evaluate function arguments with context support
                <span class="cov8" title="1">args := make([]interface{}, len(e.Args))
                for i, arg := range e.Args </span><span class="cov8" title="1">{
                        val, err := ctx.EvaluateSelectExpression(row, arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("function %s: argument %d: %w", e.Name, i+1, err)
                        }</span>
                        <span class="cov8" title="1">args[i] = val</span>
                }

                // Check arity
                <span class="cov8" title="1">minArity := fn.MinArity()
                maxArity := fn.MaxArity()
                argCount := len(args)

                if minArity &gt;= 0 &amp;&amp; argCount &lt; minArity </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("function %s: expected at least %d arguments, got %d", e.Name, minArity, argCount)
                }</span>
                <span class="cov8" title="1">if maxArity &gt;= 0 &amp;&amp; argCount &gt; maxArity </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("function %s: expected at most %d arguments, got %d", e.Name, maxArity, argCount)
                }</span>

                // Call the function
                <span class="cov8" title="1">return fn.Evaluate(args)</span>
        case *CaseExpr:<span class="cov8" title="1">
                // Evaluate WHEN clauses
                for _, whenClause := range e.WhenClauses </span><span class="cov8" title="1">{
                        conditionMet, err := ctx.EvaluateExpression(row, whenClause.Condition)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if conditionMet </span><span class="cov8" title="1">{
                                result, err := ctx.EvaluateSelectExpression(row, whenClause.Result)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">return result, nil</span>
                        }
                }
                // Evaluate ELSE clause
                <span class="cov8" title="1">if e.ElseExpr != nil </span><span class="cov8" title="1">{
                        result, err := ctx.EvaluateSelectExpression(row, e.ElseExpr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">return result, nil</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        default:<span class="cov8" title="1">
                // For all other expressions, use the standard EvaluateSelect method
                return expr.EvaluateSelect(row)</span>
        }
}

// EvaluateScalarSubquery evaluates a scalar subquery and returns its result
// NOTE: Correlated subqueries (subqueries that reference columns from outer query)
// are not currently supported. The subquery is executed independently without
// access to the outer row context.
// For non-correlated scalar subqueries, the result is cached to avoid re-execution per row.
func (ctx *ExecutionContext) EvaluateScalarSubquery(row map[string]interface{}, expr *ScalarSubqueryExpr) (interface{}, error) <span class="cov8" title="1">{
        // Check cache first for non-correlated subqueries
        // TODO: When we add correlated subquery support, we'll need to skip cache for those
        if cachedValue, exists := ctx.ScalarSubqueryCache[expr]; exists </span><span class="cov8" title="1">{
                return cachedValue, nil
        }</span>

        // Materialize subquery-local CTEs first if present
        <span class="cov8" title="1">var subqueryCtx *ExecutionContext
        if len(expr.Query.CTEs) &gt; 0 </span><span class="cov8" title="1">{
                subqueryCtx = ctx.NewChildContext()
                if err := subqueryCtx.materializeCTEs(expr.Query.CTEs); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scalar subquery CTE materialization failed: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                subqueryCtx = ctx
        }</span>

        // Execute the subquery
        // TODO: Support correlated subqueries by passing outer row context
        <span class="cov8" title="1">rows, err := subqueryCtx.executeSelect(expr.Query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scalar subquery failed: %w", err)
        }</span>

        // Scalar subquery must return exactly one row and one column
        <span class="cov8" title="1">if len(rows) == 0 </span><span class="cov8" title="1">{
                // Cache NULL result
                ctx.ScalarSubqueryCache[expr] = nil
                return nil, nil // Return NULL if subquery returns no rows
        }</span>

        <span class="cov8" title="1">if len(rows) &gt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scalar subquery returned more than one row")
        }</span>

        <span class="cov8" title="1">row0 := rows[0]
        if len(row0) != 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scalar subquery must return exactly one column, got %d", len(row0))
        }</span>

        // Get and cache the single value
        <span class="cov8" title="1">var result interface{}
        for _, v := range row0 </span><span class="cov8" title="1">{
                result = v
                break</span>
        }

        // Cache the result for subsequent rows
        <span class="cov8" title="1">ctx.ScalarSubqueryCache[expr] = result
        return result, nil</span>
}

// executeJoin executes a JOIN operation
func (ctx *ExecutionContext) executeJoin(leftRows []map[string]interface{}, leftAlias string, join Join) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        // Get right-side data
        var rightRows []map[string]interface{}
        var err error

        if join.Subquery != nil </span><span class="cov8" title="1">{
                // JOIN with subquery - use child context if subquery has CTEs to prevent scope leaking
                var subqueryCtx *ExecutionContext
                if len(join.Subquery.CTEs) &gt; 0 </span><span class="cov0" title="0">{
                        subqueryCtx = ctx.NewChildContext()
                        if err := subqueryCtx.materializeCTEs(join.Subquery.CTEs); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to materialize CTEs in JOIN subquery: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        subqueryCtx = ctx
                }</span>
                <span class="cov8" title="1">rightRows, err = subqueryCtx.executeSelect(join.Subquery)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute JOIN subquery: %w", err)
                }</span>
        } else<span class="cov8" title="1"> if join.TableName != "" </span><span class="cov8" title="1">{
                // Check if it's a CTE reference
                if cteRows, exists := ctx.CTEs[join.TableName]; exists </span><span class="cov0" title="0">{
                        rightRows = cteRows
                }</span> else<span class="cov8" title="1"> if ctx.AllCTENames[join.TableName] </span><span class="cov8" title="1">{
                        // This is a forward CTE reference (CTE defined but not yet materialized)
                        return nil, fmt.Errorf("forward CTE reference in JOIN: %s is defined but not yet materialized (CTEs must be referenced in order)", join.TableName)
                }</span> else<span class="cov8" title="1"> {
                        // Read from parquet file
                        rightRows, err = reader.ReadMultipleFiles(join.TableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read JOIN table %s: %w", join.TableName, err)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("JOIN requires table name or subquery")
        }</span>

        // Apply alias to right table rows if specified
        <span class="cov8" title="1">if join.Alias != "" </span><span class="cov8" title="1">{
                rightRows = applyTableAlias(rightRows, join.Alias)
        }</span>

        // Execute the appropriate join algorithm
        <span class="cov8" title="1">switch join.Type </span>{
        case JoinInner:<span class="cov8" title="1">
                return executeInnerJoin(leftRows, rightRows, join.Condition)</span>
        case JoinLeft:<span class="cov8" title="1">
                return executeLeftJoin(leftRows, rightRows, join.Condition)</span>
        case JoinRight:<span class="cov8" title="1">
                return executeRightJoin(leftRows, rightRows, join.Condition)</span>
        case JoinFull:<span class="cov8" title="1">
                return executeFullJoin(leftRows, rightRows, join.Condition)</span>
        case JoinCross:<span class="cov8" title="1">
                return executeCrossJoin(leftRows, rightRows)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported join type: %v", join.Type)</span>
        }
}

// applyTableAlias prefixes all column names with table alias
func applyTableAlias(rows []map[string]interface{}, alias string) []map[string]interface{} <span class="cov8" title="1">{
        if alias == "" </span><span class="cov8" title="1">{
                return rows
        }</span>

        <span class="cov8" title="1">aliasedRows := make([]map[string]interface{}, len(rows))
        for i, row := range rows </span><span class="cov8" title="1">{
                aliasedRow := make(map[string]interface{})
                for col, val := range row </span><span class="cov8" title="1">{
                        // Don't alias the special _file column
                        if col == "_file" </span><span class="cov8" title="1">{
                                aliasedRow[col] = val
                        }</span> else<span class="cov8" title="1"> {
                                aliasedRow[alias+"."+col] = val
                        }</span>
                }
                <span class="cov8" title="1">aliasedRows[i] = aliasedRow</span>
        }
        <span class="cov8" title="1">return aliasedRows</span>
}

// executeInnerJoin performs an INNER JOIN using hash join algorithm
func executeInnerJoin(leftRows, rightRows []map[string]interface{}, condition Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        // Use nested loop join for simplicity (can be optimized to hash join for equi-joins)
        for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                for _, rightRow := range rightRows </span><span class="cov8" title="1">{
                        // Merge rows
                        merged, err := mergeRows(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov8" title="1">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                result = append(result, merged)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// executeLeftJoin performs a LEFT OUTER JOIN
func executeLeftJoin(leftRows, rightRows []map[string]interface{}, condition Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        // Special case: if right side is empty, return all left rows unchanged
        // (we can't add NULL columns without knowing the right side schema)
        if len(rightRows) == 0 </span><span class="cov8" title="1">{
                return append([]map[string]interface{}{}, leftRows...), nil
        }</span>

        <span class="cov8" title="1">for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                matched := false

                for _, rightRow := range rightRows </span><span class="cov8" title="1">{
                        // Merge rows
                        merged, err := mergeRows(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov8" title="1">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                result = append(result, merged)
                                matched = true
                        }</span>
                }

                // If no match, include left row with NULL values for right columns
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        merged, err := mergeRows(leftRow, createNullRow(rightRows))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// executeRightJoin performs a RIGHT OUTER JOIN
func executeRightJoin(leftRows, rightRows []map[string]interface{}, condition Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        // Special case: if left side is empty, return all right rows unchanged
        // (we can't add NULL columns without knowing the left side schema)
        if len(leftRows) == 0 </span><span class="cov8" title="1">{
                return append([]map[string]interface{}{}, rightRows...), nil
        }</span>

        <span class="cov8" title="1">for _, rightRow := range rightRows </span><span class="cov8" title="1">{
                matched := false

                for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                        // Merge rows
                        merged, err := mergeRows(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov8" title="1">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                result = append(result, merged)
                                matched = true
                        }</span>
                }

                // If no match, include right row with NULL values for left columns
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        merged, err := mergeRows(createNullRow(leftRows), rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// executeFullJoin performs a FULL OUTER JOIN
func executeFullJoin(leftRows, rightRows []map[string]interface{}, condition Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        // Special cases: if one side is empty, return the other side unchanged
        if len(leftRows) == 0 </span><span class="cov8" title="1">{
                return append([]map[string]interface{}{}, rightRows...), nil
        }</span>
        <span class="cov8" title="1">if len(rightRows) == 0 </span><span class="cov8" title="1">{
                return append([]map[string]interface{}{}, leftRows...), nil
        }</span>

        // Track which right rows have been matched
        <span class="cov8" title="1">rightMatched := make([]bool, len(rightRows))

        // Process left rows
        for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                matched := false

                for i, rightRow := range rightRows </span><span class="cov8" title="1">{
                        // Merge rows
                        merged, err := mergeRows(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Evaluate join condition
                        <span class="cov8" title="1">match, err := condition.Evaluate(merged)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to evaluate JOIN condition: %w", err)
                        }</span>

                        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                                result = append(result, merged)
                                matched = true
                                rightMatched[i] = true
                        }</span>
                }

                // If no match, include left row with NULL values for right columns
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        merged, err := mergeRows(leftRow, createNullRow(rightRows))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        // Add unmatched right rows with NULL values for left columns
        <span class="cov8" title="1">for i, rightRow := range rightRows </span><span class="cov8" title="1">{
                if !rightMatched[i] </span><span class="cov8" title="1">{
                        merged, err := mergeRows(createNullRow(leftRows), rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// executeCrossJoin performs a CROSS JOIN (Cartesian product)
func executeCrossJoin(leftRows, rightRows []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        var result []map[string]interface{}

        for _, leftRow := range leftRows </span><span class="cov8" title="1">{
                for _, rightRow := range rightRows </span><span class="cov8" title="1">{
                        merged, err := mergeRows(leftRow, rightRow)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// mergeRows combines two rows into one
// If both left and right have the same column name, returns an error
func mergeRows(left, right map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        merged := make(map[string]interface{})

        // Copy left row
        for k, v := range left </span><span class="cov8" title="1">{
                merged[k] = v
        }</span>

        // Copy right row - check for collisions (except _file which is allowed to be duplicated)
        <span class="cov8" title="1">for k, v := range right </span><span class="cov8" title="1">{
                if _, exists := merged[k]; exists </span><span class="cov8" title="1">{
                        // Allow _file column to be duplicated - it's added by glob reads
                        // When both sides have _file, we keep both but suffix them with the table position
                        if k == "_file" </span><span class="cov8" title="1">{
                                // Keep left as _file_left and right as _file_right
                                if leftFile, ok := merged["_file"]; ok </span><span class="cov8" title="1">{
                                        delete(merged, "_file")
                                        merged["_file_left"] = leftFile
                                        merged["_file_right"] = v
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">return nil, fmt.Errorf("column name collision in JOIN: %q exists in both tables. Use table aliases to disambiguate (e.g., SELECT t1.%s, t2.%s FROM ...)", k, k, k)</span>
                }
                <span class="cov8" title="1">merged[k] = v</span>
        }

        <span class="cov8" title="1">return merged, nil</span>
}

// createNullRow creates a row with NULL values for all columns from a sample row set
func createNullRow(rows []map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">nullRow := make(map[string]interface{})
        // Use first row as template to get column names
        for col := range rows[0] </span><span class="cov8" title="1">{
                nullRow[col] = nil
        }</span>

        <span class="cov8" title="1">return nullRow</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package query

import (
        "fmt"
        "math"
        "reflect"
        "sort"
        "strings"
)

// abs returns the absolute value of a float64
func abs(x float64) float64 <span class="cov8" title="1">{
        return math.Abs(x)
}</span>

// compare compares two values using the given operator
func compare(left interface{}, operator TokenType, right interface{}) (bool, error) <span class="cov8" title="1">{
        // Handle nil values
        if left == nil || right == nil </span><span class="cov8" title="1">{
                if operator == TokenEqual </span><span class="cov8" title="1">{
                        return left == right, nil
                }</span>
                <span class="cov8" title="1">if operator == TokenNotEqual </span><span class="cov8" title="1">{
                        return left != right, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        // Try numeric comparison
        <span class="cov8" title="1">leftNum, leftIsNum := toFloat64(left)
        rightNum, rightIsNum := toFloat64(right)

        if leftIsNum &amp;&amp; rightIsNum </span><span class="cov8" title="1">{
                return compareNumbers(leftNum, operator, rightNum), nil
        }</span>

        // Try string comparison
        <span class="cov8" title="1">leftStr, leftIsStr := toString(left)
        rightStr, rightIsStr := toString(right)

        if leftIsStr &amp;&amp; rightIsStr </span><span class="cov8" title="1">{
                return compareStrings(leftStr, operator, rightStr), nil
        }</span>

        // Try boolean comparison
        <span class="cov8" title="1">leftBool, leftIsBool := toBool(left)
        rightBool, rightIsBool := toBool(right)

        if leftIsBool &amp;&amp; rightIsBool </span><span class="cov8" title="1">{
                return compareBools(leftBool, operator, rightBool), nil
        }</span>

        // Type mismatch
        <span class="cov8" title="1">return false, fmt.Errorf("cannot compare %T with %T", left, right)</span>
}

// toFloat64 converts a value to float64 if possible
func toFloat64(v interface{}) (float64, bool) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case float64:<span class="cov8" title="1">
                return val, true</span>
        case float32:<span class="cov0" title="0">
                return float64(val), true</span>
        case int:<span class="cov8" title="1">
                return float64(val), true</span>
        case int8:<span class="cov0" title="0">
                return float64(val), true</span>
        case int16:<span class="cov0" title="0">
                return float64(val), true</span>
        case int32:<span class="cov8" title="1">
                return float64(val), true</span>
        case int64:<span class="cov8" title="1">
                return float64(val), true</span>
        case uint:<span class="cov0" title="0">
                return float64(val), true</span>
        case uint8:<span class="cov0" title="0">
                return float64(val), true</span>
        case uint16:<span class="cov0" title="0">
                return float64(val), true</span>
        case uint32:<span class="cov0" title="0">
                return float64(val), true</span>
        case uint64:<span class="cov0" title="0">
                return float64(val), true</span>
        default:<span class="cov8" title="1">
                return 0, false</span>
        }
}

// toString converts a value to string if possible
func toString(v interface{}) (string, bool) <span class="cov8" title="1">{
        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                return str, true
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// toBool converts a value to bool if possible
func toBool(v interface{}) (bool, bool) <span class="cov8" title="1">{
        if b, ok := v.(bool); ok </span><span class="cov8" title="1">{
                return b, true
        }</span>
        <span class="cov8" title="1">return false, false</span>
}

// compareNumbers compares two numbers
func compareNumbers(left float64, operator TokenType, right float64) bool <span class="cov8" title="1">{
        const epsilon = 1e-9 // Use small epsilon for floating point comparison
        switch operator </span>{
        case TokenEqual:<span class="cov8" title="1">
                // Use relative epsilon for large numbers, absolute for small
                diff := abs(left - right)
                maxAbs := max(abs(left), abs(right))
                // Use epsilon scaled by the larger of 1.0 or maxAbs for consistent comparison
                threshold := epsilon * max(1.0, maxAbs)
                return diff &lt; threshold</span>
        case TokenNotEqual:<span class="cov8" title="1">
                // Use relative epsilon for large numbers, absolute for small
                diff := abs(left - right)
                maxAbs := max(abs(left), abs(right))
                // Use epsilon scaled by the larger of 1.0 or maxAbs for consistent comparison
                threshold := epsilon * max(1.0, maxAbs)
                return diff &gt;= threshold</span>
        case TokenLess:<span class="cov8" title="1">
                return left &lt; right</span>
        case TokenGreater:<span class="cov8" title="1">
                return left &gt; right</span>
        case TokenLessEqual:<span class="cov8" title="1">
                return left &lt;= right</span>
        case TokenGreaterEqual:<span class="cov8" title="1">
                return left &gt;= right</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// compareStrings compares two strings (case-sensitive)
func compareStrings(left string, operator TokenType, right string) bool <span class="cov8" title="1">{
        switch operator </span>{
        case TokenEqual:<span class="cov8" title="1">
                return left == right</span>
        case TokenNotEqual:<span class="cov8" title="1">
                return left != right</span>
        case TokenLess:<span class="cov8" title="1">
                return left &lt; right</span>
        case TokenGreater:<span class="cov8" title="1">
                return left &gt; right</span>
        case TokenLessEqual:<span class="cov8" title="1">
                return left &lt;= right</span>
        case TokenGreaterEqual:<span class="cov8" title="1">
                return left &gt;= right</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// compareBools compares two booleans
func compareBools(left bool, operator TokenType, right bool) bool <span class="cov8" title="1">{
        switch operator </span>{
        case TokenEqual:<span class="cov8" title="1">
                return left == right</span>
        case TokenNotEqual:<span class="cov8" title="1">
                return left != right</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ApplyFilter applies a filter to rows
func ApplyFilter(rows []map[string]interface{}, filter Expression) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        return ApplyFilterWithContext(rows, filter, nil)
}</span>

// ApplyFilterWithContext applies a filter to rows with execution context for subquery support
func ApplyFilterWithContext(rows []map[string]interface{}, filter Expression, ctx *ExecutionContext) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if filter == nil </span><span class="cov8" title="1">{
                return rows, nil
        }</span>

        <span class="cov8" title="1">filtered := make([]map[string]interface{}, 0)
        for _, row := range rows </span><span class="cov8" title="1">{
                var match bool
                var err error

                // Use context-aware evaluation if context is provided (handles nested subqueries in compound expressions)
                if ctx != nil </span><span class="cov0" title="0">{
                        match, err = ctx.EvaluateExpression(row, filter)
                }</span> else<span class="cov8" title="1"> {
                        match, err = filter.Evaluate(row)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        filtered = append(filtered, row)
                }</span>
        }

        <span class="cov8" title="1">return filtered, nil</span>
}

// GetColumnNames returns all unique column names from rows
func GetColumnNames(rows []map[string]interface{}) []string <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">seen := make(map[string]bool)
        columns := make([]string, 0)

        for _, row := range rows </span><span class="cov8" title="1">{
                for col := range row </span><span class="cov8" title="1">{
                        if !seen[col] </span><span class="cov8" title="1">{
                                seen[col] = true
                                columns = append(columns, col)
                        }</span>
                }
        }

        <span class="cov8" title="1">return columns</span>
}

// ApplySelectListAfterWindows applies column projection after window functions have been computed
// Window expressions are treated as column references (already computed values)
func ApplySelectListAfterWindows(rows []map[string]interface{}, selectList []SelectItem) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        <span class="cov0" title="0">projected := make([]map[string]interface{}, 0, len(rows))

        for _, row := range rows </span><span class="cov0" title="0">{
                newRow := make(map[string]interface{})

                for _, item := range selectList </span><span class="cov0" title="0">{
                        // Determine the column name for the result
                        columnName := item.Alias
                        if columnName == "" </span><span class="cov0" title="0">{
                                if colRef, ok := item.Expr.(*ColumnRef); ok </span><span class="cov0" title="0">{
                                        columnName = colRef.Column
                                }</span> else<span class="cov0" title="0"> if winExpr, ok := item.Expr.(*WindowExpr); ok </span><span class="cov0" title="0">{
                                        // Window functions already computed, use function name as column name
                                        columnName = winExpr.Function
                                }</span> else<span class="cov0" title="0"> if funcCall, ok := item.Expr.(*FunctionCall); ok </span><span class="cov0" title="0">{
                                        columnName = funcCall.Name
                                }</span> else<span class="cov0" title="0"> {
                                        columnName = fmt.Sprintf("col_%d", len(newRow))
                                }</span>
                        }

                        // For window expressions, the value is already in the row with the column name
                        <span class="cov0" title="0">if _, ok := item.Expr.(*WindowExpr); ok </span><span class="cov0" title="0">{
                                value, exists := row[columnName]
                                if !exists </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("window function result %q not found in row", columnName)
                                }</span>
                                <span class="cov0" title="0">newRow[columnName] = value</span>
                        } else<span class="cov0" title="0"> {
                                // Evaluate other expressions normally
                                value, err := item.Expr.EvaluateSelect(row)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">newRow[columnName] = value</span>
                        }
                }

                <span class="cov0" title="0">projected = append(projected, newRow)</span>
        }

        <span class="cov0" title="0">return projected, nil</span>
}

// ApplySelectList applies column projection to rows based on the SELECT list
func ApplySelectList(rows []map[string]interface{}, selectList []SelectItem) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        return ApplySelectListWithContext(rows, selectList, nil)
}</span>

// ApplySelectListWithContext applies column projection with execution context for scalar subquery support
func ApplySelectListWithContext(rows []map[string]interface{}, selectList []SelectItem, ctx *ExecutionContext) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return rows, nil
        }</span>

        // If no select list or only SELECT *, return all columns
        <span class="cov8" title="1">if len(selectList) == 0 </span><span class="cov8" title="1">{
                return rows, nil
        }</span>

        // Check if it's just SELECT *
        <span class="cov8" title="1">if len(selectList) == 1 </span><span class="cov8" title="1">{
                if colRef, ok := selectList[0].Expr.(*ColumnRef); ok &amp;&amp; colRef.Column == "*" </span><span class="cov8" title="1">{
                        return rows, nil
                }</span>
        }

        <span class="cov8" title="1">projected := make([]map[string]interface{}, 0, len(rows))

        for _, row := range rows </span><span class="cov8" title="1">{
                newRow := make(map[string]interface{})

                for _, item := range selectList </span><span class="cov8" title="1">{
                        // Special handling for SELECT * in mixed select lists
                        if colRef, ok := item.Expr.(*ColumnRef); ok &amp;&amp; colRef.Column == "*" </span><span class="cov0" title="0">{
                                // Expand all columns from the row instead of treating * as a column
                                for col, val := range row </span><span class="cov0" title="0">{
                                        newRow[col] = val
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // Evaluate the select expression
                        <span class="cov8" title="1">var value interface{}
                        var err error

                        // Use context-aware evaluation if context is provided (handles nested subqueries in expressions)
                        if ctx != nil </span><span class="cov8" title="1">{
                                value, err = ctx.EvaluateSelectExpression(row, item.Expr)
                        }</span> else<span class="cov8" title="1"> {
                                value, err = item.Expr.EvaluateSelect(row)
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>

                        // Determine the column name to use
                        <span class="cov8" title="1">columnName := item.Alias
                        if columnName == "" </span><span class="cov8" title="1">{
                                // If no alias, try to derive name from expression
                                if colRef, ok := item.Expr.(*ColumnRef); ok </span><span class="cov8" title="1">{
                                        columnName = colRef.Column
                                }</span> else<span class="cov8" title="1"> if funcCall, ok := item.Expr.(*FunctionCall); ok </span><span class="cov0" title="0">{
                                        // For function calls, use the function name as column name
                                        columnName = funcCall.Name
                                }</span> else<span class="cov8" title="1"> if _, ok := item.Expr.(*LiteralExpr); ok </span><span class="cov8" title="1">{
                                        // For literals, use a generated name
                                        columnName = fmt.Sprintf("literal_%d", len(newRow))
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback: use a generated name
                                        columnName = fmt.Sprintf("col_%d", len(newRow))
                                }</span>
                        }

                        <span class="cov8" title="1">newRow[columnName] = value</span>
                }

                <span class="cov8" title="1">projected = append(projected, newRow)</span>
        }

        <span class="cov8" title="1">return projected, nil</span>
}

// ApplyOrderBy sorts rows based on ORDER BY clause
func ApplyOrderBy(rows []map[string]interface{}, orderBy []OrderByItem) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if len(rows) == 0 || len(orderBy) == 0 </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        // Create a copy to avoid modifying the original slice
        <span class="cov8" title="1">sorted := make([]map[string]interface{}, len(rows))
        copy(sorted, rows)

        // Sort the rows
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                for _, item := range orderBy </span><span class="cov8" title="1">{
                        // Get values for the column
                        valI, existsI := sorted[i][item.Column]
                        valJ, existsJ := sorted[j][item.Column]

                        // Handle missing columns (treat as NULL, which sorts first)
                        if !existsI &amp;&amp; !existsJ </span><span class="cov0" title="0">{
                                continue</span> // Both NULL, try next column
                        }
                        <span class="cov8" title="1">if !existsI </span><span class="cov0" title="0">{
                                return !item.Desc // NULL sorts first (or last if DESC)
                        }</span>
                        <span class="cov8" title="1">if !existsJ </span><span class="cov0" title="0">{
                                return item.Desc // NULL sorts first (or last if DESC)
                        }</span>

                        // Compare the values
                        <span class="cov8" title="1">cmp := compareValues(valI, valJ)
                        if cmp != 0 </span><span class="cov8" title="1">{
                                if item.Desc </span><span class="cov8" title="1">{
                                        return cmp &gt; 0
                                }</span>
                                <span class="cov8" title="1">return cmp &lt; 0</span>
                        }
                        // Values are equal, continue to next ORDER BY column
                }
                <span class="cov0" title="0">return false</span> // All columns equal
        })

        <span class="cov8" title="1">return sorted, nil</span>
}

// compareValues compares two values and returns:
// -1 if a &lt; b
//
//        0 if a == b
//
// +1 if a &gt; b
func compareValues(a, b interface{}) int <span class="cov8" title="1">{
        // Handle nil values
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if a == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                return 1
        }</span>

        // Try numeric comparison
        <span class="cov8" title="1">aNum, aIsNum := toFloat64(a)
        bNum, bIsNum := toFloat64(b)
        if aIsNum &amp;&amp; bIsNum </span><span class="cov8" title="1">{
                if aNum &lt; bNum </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">if aNum &gt; bNum </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Try string comparison
        <span class="cov8" title="1">aStr, aIsStr := toString(a)
        bStr, bIsStr := toString(b)
        if aIsStr &amp;&amp; bIsStr </span><span class="cov8" title="1">{
                if aStr &lt; bStr </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">if aStr &gt; bStr </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Try boolean comparison
        <span class="cov0" title="0">aBool, aIsBool := toBool(a)
        bBool, bIsBool := toBool(b)
        if aIsBool &amp;&amp; bIsBool </span><span class="cov0" title="0">{
                if !aBool &amp;&amp; bBool </span><span class="cov0" title="0">{
                        return -1 // false &lt; true
                }</span>
                <span class="cov0" title="0">if aBool &amp;&amp; !bBool </span><span class="cov0" title="0">{
                        return 1 // true &gt; false
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // Type mismatch or unsupported types - treat as equal
        <span class="cov0" title="0">return 0</span>
}

// ApplyLimitOffset applies LIMIT and OFFSET to rows
func ApplyLimitOffset(rows []map[string]interface{}, limit *int64, offset *int64) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        <span class="cov8" title="1">start := int64(0)
        if offset != nil &amp;&amp; *offset &gt; 0 </span><span class="cov8" title="1">{
                start = *offset
        }</span>

        // If offset is beyond the end, return empty
        <span class="cov8" title="1">if start &gt;= int64(len(rows)) </span><span class="cov8" title="1">{
                return []map[string]interface{}{}, nil
        }</span>

        <span class="cov8" title="1">end := int64(len(rows))
        if limit != nil </span><span class="cov8" title="1">{
                if *limit == 0 </span><span class="cov8" title="1">{
                        // LIMIT 0 returns empty result
                        return []map[string]interface{}{}, nil
                }</span>
                <span class="cov8" title="1">if *limit &gt; 0 </span><span class="cov8" title="1">{
                        end = start + *limit
                        if end &gt; int64(len(rows)) </span><span class="cov8" title="1">{
                                end = int64(len(rows))
                        }</span>
                }
        }

        <span class="cov8" title="1">return rows[start:end], nil</span>
}

// ApplyDistinct removes duplicate rows
func ApplyDistinct(rows []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov8" title="1">{
                return rows, nil
        }</span>

        // Use a map to track seen rows (hash-based deduplication)
        <span class="cov8" title="1">seen := make(map[string]bool)
        distinct := make([]map[string]interface{}, 0)

        for _, row := range rows </span><span class="cov8" title="1">{
                // Create a hash key from the row values
                key := rowToKey(row)
                if !seen[key] </span><span class="cov8" title="1">{
                        seen[key] = true
                        distinct = append(distinct, row)
                }</span>
        }

        <span class="cov8" title="1">return distinct, nil</span>
}

// rowToKey creates a unique string key from a row for deduplication
func rowToKey(row map[string]interface{}) string <span class="cov8" title="1">{
        // Get all column names sorted for consistent key generation
        columns := make([]string, 0, len(row))
        for col := range row </span><span class="cov8" title="1">{
                columns = append(columns, col)
        }</span>
        <span class="cov8" title="1">sort.Strings(columns)

        // Build key from column values
        var key strings.Builder
        for i, col := range columns </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        key.WriteString("\x00||\x00") // Use unlikely separator to avoid collisions
                }</span>
                <span class="cov8" title="1">key.WriteString(col)
                key.WriteString("\x00:\x00")
                key.WriteString(fmt.Sprintf("%#v", row[col]))</span> // Use %#v for better type differentiation
        }

        <span class="cov8" title="1">return key.String()</span>
}

// matchLikePattern matches a string against a SQL LIKE pattern
// % matches any sequence of characters
// _ matches any single character
func matchLikePattern(str, pattern string) bool <span class="cov8" title="1">{
        // Convert pattern to segments split by %
        segments := strings.Split(pattern, "%")

        // Track position in the string
        pos := 0

        for i, segment := range segments </span><span class="cov8" title="1">{
                if segment == "" </span><span class="cov8" title="1">{
                        // Empty segment means % was at start/end or consecutive %%
                        continue</span>
                }

                // Match the segment (handling _ wildcards)
                <span class="cov8" title="1">matchPos := findSegmentMatch(str[pos:], segment)
                if matchPos == -1 </span><span class="cov8" title="1">{
                        return false
                }</span>

                // For the first segment, it must match at the start (unless pattern starts with %)
                <span class="cov8" title="1">if i == 0 &amp;&amp; !strings.HasPrefix(pattern, "%") &amp;&amp; matchPos != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">pos += matchPos + len(segment)</span>
        }

        // For the last segment, it must match at the end (unless pattern ends with %)
        <span class="cov8" title="1">if !strings.HasSuffix(pattern, "%") &amp;&amp; pos != len(str) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// findSegmentMatch finds the position where a segment matches in the string
// Returns -1 if no match found
// Handles _ wildcard matching any single character
func findSegmentMatch(str, segment string) int <span class="cov8" title="1">{
        if len(segment) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // If no _ wildcards, use simple string search
        <span class="cov8" title="1">if !strings.Contains(segment, "_") </span><span class="cov8" title="1">{
                idx := strings.Index(str, segment)
                return idx
        }</span>

        // Handle _ wildcards
        <span class="cov8" title="1">for i := 0; i &lt;= len(str)-len(segment); i++ </span><span class="cov8" title="1">{
                match := true
                for j := 0; j &lt; len(segment); j++ </span><span class="cov8" title="1">{
                        if segment[j] != '_' &amp;&amp; str[i+j] != segment[j] </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}

// init registers reflection for common types
func init() <span class="cov8" title="1">{
        // This ensures reflect package is properly initialized
        _ = reflect.TypeOf(0)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package query

import (
        "fmt"
        "math"
        "math/rand/v2"
        "strconv"
        "strings"
        "sync"
        "time"
)

// Function represents a scalar function that can be evaluated
type Function interface {
        // Name returns the function name (case-insensitive)
        Name() string
        // MinArity returns the minimum number of arguments (-1 for variadic with no minimum)
        MinArity() int
        // MaxArity returns the maximum number of arguments (-1 for unlimited)
        MaxArity() int
        // Evaluate evaluates the function with the given arguments
        Evaluate(args []interface{}) (interface{}, error)
}

// FunctionRegistry manages function lookup and registration
type FunctionRegistry struct {
        mu        sync.RWMutex
        functions map[string]Function
}

// NewFunctionRegistry creates a new function registry
func NewFunctionRegistry() *FunctionRegistry <span class="cov8" title="1">{
        return &amp;FunctionRegistry{
                functions: make(map[string]Function),
        }
}</span>

// Register registers a function
func (r *FunctionRegistry) Register(f Function) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.functions[strings.ToUpper(f.Name())] = f
}</span>

// Get retrieves a function by name (case-insensitive)
func (r *FunctionRegistry) Get(name string) (Function, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        f, exists := r.functions[strings.ToUpper(name)]
        return f, exists
}</span>

// globalRegistry is the default function registry
var globalRegistry *FunctionRegistry

func init() <span class="cov8" title="1">{
        globalRegistry = NewFunctionRegistry()

        // Register string functions
        globalRegistry.Register(&amp;UpperFunc{})
        globalRegistry.Register(&amp;LowerFunc{})
        globalRegistry.Register(&amp;ConcatFunc{})
        globalRegistry.Register(&amp;LengthFunc{})
        globalRegistry.Register(&amp;TrimFunc{})
        globalRegistry.Register(&amp;LTrimFunc{})
        globalRegistry.Register(&amp;RTrimFunc{})
        globalRegistry.Register(&amp;SubstringFunc{})
        globalRegistry.Register(&amp;ReplaceFunc{})
        globalRegistry.Register(&amp;SplitFunc{})
        globalRegistry.Register(&amp;ReverseFunc{})
        globalRegistry.Register(&amp;ContainsFunc{})
        globalRegistry.Register(&amp;StartsWithFunc{})
        globalRegistry.Register(&amp;EndsWithFunc{})
        globalRegistry.Register(&amp;RepeatFunc{})

        // Register math functions
        globalRegistry.Register(&amp;AbsFunc{})
        globalRegistry.Register(&amp;RoundFunc{})
        globalRegistry.Register(&amp;FloorFunc{})
        globalRegistry.Register(&amp;CeilFunc{})
        globalRegistry.Register(&amp;ModFunc{})
        globalRegistry.Register(&amp;SqrtFunc{})
        globalRegistry.Register(&amp;PowFunc{})
        globalRegistry.Register(&amp;SignFunc{})
        globalRegistry.Register(&amp;TruncFunc{})
        globalRegistry.Register(&amp;RandomFunc{})
        globalRegistry.Register(&amp;MinFunc{})
        globalRegistry.Register(&amp;MaxFunc{})

        // Register date/time functions
        globalRegistry.Register(&amp;NowFunc{})
        globalRegistry.Register(&amp;CurrentDateFunc{})
        globalRegistry.Register(&amp;CurrentTimeFunc{})
        globalRegistry.Register(&amp;DateTruncFunc{})
        globalRegistry.Register(&amp;DatePartFunc{})
        globalRegistry.Register(&amp;DateAddFunc{})
        globalRegistry.Register(&amp;DateSubFunc{})
        globalRegistry.Register(&amp;DateDiffFunc{})
        globalRegistry.Register(&amp;YearFunc{})
        globalRegistry.Register(&amp;MonthFunc{})

        // Register type conversion functions
        globalRegistry.Register(&amp;CastFunc{})
        globalRegistry.Register(&amp;TryCastFunc{})
        globalRegistry.Register(&amp;ToStringFunc{})
        globalRegistry.Register(&amp;ToNumberFunc{})
        globalRegistry.Register(&amp;ToDateFunc{})

        // Register conditional functions
        globalRegistry.Register(&amp;CoalesceFunc{})
        globalRegistry.Register(&amp;NullIfFunc{})
}</span>

// GetGlobalRegistry returns the global function registry
func GetGlobalRegistry() *FunctionRegistry <span class="cov8" title="1">{
        return globalRegistry
}</span>

// Helper function to convert value to string
func valueToString(v interface{}) (string, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return val, nil</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", val), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", val), nil</span>
        case float32, float64:<span class="cov8" title="1">
                return fmt.Sprintf("%v", val), nil</span>
        case bool:<span class="cov8" title="1">
                return fmt.Sprintf("%t", val), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("cannot convert %T to string", v)</span>
        }
}

// Helper function to convert value to number
func valueToNumber(v interface{}) (float64, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case float64:<span class="cov8" title="1">
                return val, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(val), nil</span>
        case uint:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint64:<span class="cov0" title="0">
                return float64(val), nil</span>
        case string:<span class="cov8" title="1">
                // Try to parse string as number
                return strconv.ParseFloat(val, 64)</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot convert %T to number", v)</span>
        }
}

// String Functions

// UpperFunc converts a string to uppercase
type UpperFunc struct{}

func (f *UpperFunc) Name() string  <span class="cov8" title="1">{ return "UPPER" }</span>
func (f *UpperFunc) MinArity() int <span class="cov8" title="1">{ return 1 }</span>
func (f *UpperFunc) MaxArity() int <span class="cov8" title="1">{ return 1 }</span>
func (f *UpperFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("UPPER: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.ToUpper(str), nil</span>
}

// LowerFunc converts a string to lowercase
type LowerFunc struct{}

func (f *LowerFunc) Name() string  <span class="cov8" title="1">{ return "LOWER" }</span>
func (f *LowerFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LowerFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LowerFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LOWER: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.ToLower(str), nil</span>
}

// ConcatFunc concatenates multiple strings
type ConcatFunc struct{}

func (f *ConcatFunc) Name() string  <span class="cov8" title="1">{ return "CONCAT" }</span>
func (f *ConcatFunc) MinArity() int <span class="cov8" title="1">{ return 1 }</span>
func (f *ConcatFunc) MaxArity() int <span class="cov8" title="1">{ return -1 }</span> // variadic
func (f *ConcatFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        var builder strings.Builder
        for i, arg := range args </span><span class="cov8" title="1">{
                str, err := valueToString(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("CONCAT: argument %d: %w", i+1, err)
                }</span>
                <span class="cov8" title="1">builder.WriteString(str)</span>
        }
        <span class="cov8" title="1">return builder.String(), nil</span>
}

// LengthFunc returns the length of a string
type LengthFunc struct{}

func (f *LengthFunc) Name() string  <span class="cov8" title="1">{ return "LENGTH" }</span>
func (f *LengthFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LengthFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LengthFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LENGTH: %w", err)
        }</span>
        <span class="cov8" title="1">return int64(len(str)), nil</span>
}

// TrimFunc trims whitespace from both ends of a string
type TrimFunc struct{}

func (f *TrimFunc) Name() string  <span class="cov8" title="1">{ return "TRIM" }</span>
func (f *TrimFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *TrimFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *TrimFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRIM: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(str), nil</span>
}

// Math Functions

// AbsFunc returns the absolute value of a number
type AbsFunc struct{}

func (f *AbsFunc) Name() string  <span class="cov8" title="1">{ return "ABS" }</span>
func (f *AbsFunc) MinArity() int <span class="cov8" title="1">{ return 1 }</span>
func (f *AbsFunc) MaxArity() int <span class="cov8" title="1">{ return 1 }</span>
func (f *AbsFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ABS: %w", err)
        }</span>
        <span class="cov8" title="1">return math.Abs(num), nil</span>
}

// RoundFunc rounds a number to the specified number of decimal places
type RoundFunc struct{}

func (f *RoundFunc) Name() string  <span class="cov8" title="1">{ return "ROUND" }</span>
func (f *RoundFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *RoundFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *RoundFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ROUND: %w", err)
        }</span>

        // Default to 0 decimal places
        <span class="cov8" title="1">decimals := 0.0
        if len(args) == 2 </span><span class="cov8" title="1">{
                decimals, err = valueToNumber(args[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ROUND: decimals argument: %w", err)
                }</span>
        }

        <span class="cov8" title="1">multiplier := math.Pow(10, float64(decimals))
        return math.Round(num*multiplier) / multiplier, nil</span>
}

// FloorFunc returns the largest integer less than or equal to a number
type FloorFunc struct{}

func (f *FloorFunc) Name() string  <span class="cov8" title="1">{ return "FLOOR" }</span>
func (f *FloorFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *FloorFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *FloorFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FLOOR: %w", err)
        }</span>
        <span class="cov8" title="1">return math.Floor(num), nil</span>
}

// CeilFunc returns the smallest integer greater than or equal to a number
type CeilFunc struct{}

func (f *CeilFunc) Name() string  <span class="cov8" title="1">{ return "CEIL" }</span>
func (f *CeilFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *CeilFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *CeilFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CEIL: %w", err)
        }</span>
        <span class="cov8" title="1">return math.Ceil(num), nil</span>
}

// ModFunc returns the remainder of division
type ModFunc struct{}

func (f *ModFunc) Name() string  <span class="cov8" title="1">{ return "MOD" }</span>
func (f *ModFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *ModFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *ModFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        dividend, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MOD: dividend: %w", err)
        }</span>

        <span class="cov8" title="1">divisor, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MOD: divisor: %w", err)
        }</span>

        <span class="cov8" title="1">if divisor == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MOD: division by zero")
        }</span>

        <span class="cov8" title="1">return math.Mod(dividend, divisor), nil</span>
}

// Additional String Functions

// LTrimFunc trims whitespace from the left side of a string
type LTrimFunc struct{}

func (f *LTrimFunc) Name() string  <span class="cov8" title="1">{ return "LTRIM" }</span>
func (f *LTrimFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LTrimFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *LTrimFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LTRIM: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimLeft(str, " \t\n\r"), nil</span>
}

// RTrimFunc trims whitespace from the right side of a string
type RTrimFunc struct{}

func (f *RTrimFunc) Name() string  <span class="cov8" title="1">{ return "RTRIM" }</span>
func (f *RTrimFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *RTrimFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *RTrimFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RTRIM: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimRight(str, " \t\n\r"), nil</span>
}

// SubstringFunc extracts a substring (1-indexed, SQL style)
type SubstringFunc struct{}

func (f *SubstringFunc) Name() string  <span class="cov8" title="1">{ return "SUBSTRING" }</span>
func (f *SubstringFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *SubstringFunc) MaxArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *SubstringFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING: %w", err)
        }</span>

        <span class="cov8" title="1">start, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SUBSTRING: start: %w", err)
        }</span>
        <span class="cov8" title="1">startIdx := int(start) - 1 // SQL uses 1-based indexing

        if startIdx &lt; 0 </span><span class="cov0" title="0">{
                startIdx = 0
        }</span>
        <span class="cov8" title="1">if startIdx &gt;= len(str) </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if len(args) == 3 </span><span class="cov8" title="1">{
                length, err := valueToNumber(args[2])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("SUBSTRING: length: %w", err)
                }</span>
                <span class="cov8" title="1">lengthInt := int(length)
                if lengthInt &lt; 0 </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">endIdx := startIdx + lengthInt
                if endIdx &gt; len(str) </span><span class="cov8" title="1">{
                        endIdx = len(str)
                }</span>
                <span class="cov8" title="1">return str[startIdx:endIdx], nil</span>
        }

        <span class="cov8" title="1">return str[startIdx:], nil</span>
}

// ReplaceFunc replaces occurrences of a substring
type ReplaceFunc struct{}

func (f *ReplaceFunc) Name() string  <span class="cov8" title="1">{ return "REPLACE" }</span>
func (f *ReplaceFunc) MinArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *ReplaceFunc) MaxArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *ReplaceFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPLACE: %w", err)
        }</span>

        <span class="cov8" title="1">old, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPLACE: old: %w", err)
        }</span>

        <span class="cov8" title="1">new, err := valueToString(args[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPLACE: new: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.ReplaceAll(str, old, new), nil</span>
}

// SplitFunc splits a string by a delimiter
type SplitFunc struct{}

func (f *SplitFunc) Name() string  <span class="cov8" title="1">{ return "SPLIT" }</span>
func (f *SplitFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *SplitFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *SplitFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SPLIT: %w", err)
        }</span>

        <span class="cov8" title="1">delim, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SPLIT: delimiter: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.Split(str, delim), nil</span>
}

// ReverseFunc reverses a string
type ReverseFunc struct{}

func (f *ReverseFunc) Name() string  <span class="cov8" title="1">{ return "REVERSE" }</span>
func (f *ReverseFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ReverseFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ReverseFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REVERSE: %w", err)
        }</span>

        <span class="cov8" title="1">runes := []rune(str)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov8" title="1">return string(runes), nil</span>
}

// ContainsFunc checks if a string contains a substring
type ContainsFunc struct{}

func (f *ContainsFunc) Name() string  <span class="cov8" title="1">{ return "CONTAINS" }</span>
func (f *ContainsFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *ContainsFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *ContainsFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CONTAINS: %w", err)
        }</span>

        <span class="cov8" title="1">substr, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CONTAINS: substring: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.Contains(str, substr), nil</span>
}

// StartsWithFunc checks if a string starts with a prefix
type StartsWithFunc struct{}

func (f *StartsWithFunc) Name() string  <span class="cov8" title="1">{ return "STARTS_WITH" }</span>
func (f *StartsWithFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *StartsWithFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *StartsWithFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("STARTS_WITH: %w", err)
        }</span>

        <span class="cov8" title="1">prefix, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("STARTS_WITH: prefix: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.HasPrefix(str, prefix), nil</span>
}

// EndsWithFunc checks if a string ends with a suffix
type EndsWithFunc struct{}

func (f *EndsWithFunc) Name() string  <span class="cov8" title="1">{ return "ENDS_WITH" }</span>
func (f *EndsWithFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *EndsWithFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *EndsWithFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ENDS_WITH: %w", err)
        }</span>

        <span class="cov8" title="1">suffix, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ENDS_WITH: suffix: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.HasSuffix(str, suffix), nil</span>
}

// RepeatFunc repeats a string n times
type RepeatFunc struct{}

func (f *RepeatFunc) Name() string  <span class="cov8" title="1">{ return "REPEAT" }</span>
func (f *RepeatFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *RepeatFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *RepeatFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        str, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPEAT: %w", err)
        }</span>

        <span class="cov8" title="1">count, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPEAT: count: %w", err)
        }</span>

        <span class="cov8" title="1">countInt := int(count)
        if countInt &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPEAT: count must be non-negative, got %d", countInt)
        }</span>
        <span class="cov8" title="1">if countInt &gt; 1000000 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPEAT: count too large (max 1000000), got %d", countInt)
        }</span>
        // Prevent memory exhaustion from large strings repeated many times
        <span class="cov8" title="1">const maxTotalBytes = 10 * 1024 * 1024 // 10MB
        if len(str)*countInt &gt; maxTotalBytes </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("REPEAT: result would be too large (max %d bytes), got %d * %d = %d bytes",
                        maxTotalBytes, len(str), countInt, len(str)*countInt)
        }</span>

        <span class="cov8" title="1">return strings.Repeat(str, countInt), nil</span>
}

// Additional Math Functions

// SqrtFunc returns the square root
type SqrtFunc struct{}

func (f *SqrtFunc) Name() string  <span class="cov8" title="1">{ return "SQRT" }</span>
func (f *SqrtFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *SqrtFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *SqrtFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SQRT: %w", err)
        }</span>
        <span class="cov8" title="1">if num &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SQRT: negative number")
        }</span>
        <span class="cov8" title="1">return math.Sqrt(num), nil</span>
}

// PowFunc returns x raised to the power of y
type PowFunc struct{}

func (f *PowFunc) Name() string  <span class="cov8" title="1">{ return "POW" }</span>
func (f *PowFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *PowFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *PowFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        x, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("POW: base: %w", err)
        }</span>

        <span class="cov8" title="1">y, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("POW: exponent: %w", err)
        }</span>

        <span class="cov8" title="1">return math.Pow(x, y), nil</span>
}

// SignFunc returns the sign of a number (-1, 0, or 1)
type SignFunc struct{}

func (f *SignFunc) Name() string  <span class="cov8" title="1">{ return "SIGN" }</span>
func (f *SignFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *SignFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *SignFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SIGN: %w", err)
        }</span>

        <span class="cov8" title="1">if num &lt; 0 </span><span class="cov8" title="1">{
                return float64(-1), nil
        }</span>
        <span class="cov8" title="1">if num &gt; 0 </span><span class="cov8" title="1">{
                return float64(1), nil
        }</span>
        <span class="cov8" title="1">return float64(0), nil</span>
}

// TruncFunc truncates a number to an integer
type TruncFunc struct{}

func (f *TruncFunc) Name() string  <span class="cov8" title="1">{ return "TRUNC" }</span>
func (f *TruncFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *TruncFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *TruncFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        num, err := valueToNumber(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TRUNC: %w", err)
        }</span>
        <span class="cov8" title="1">return math.Trunc(num), nil</span>
}

// RandomFunc returns a random number between 0 and 1
type RandomFunc struct{}

func (f *RandomFunc) Name() string  <span class="cov8" title="1">{ return "RANDOM" }</span>
func (f *RandomFunc) MinArity() int <span class="cov8" title="1">{ return 0 }</span>
func (f *RandomFunc) MaxArity() int <span class="cov8" title="1">{ return 0 }</span>
func (f *RandomFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return rand.Float64(), nil
}</span>

// MinFunc returns the minimum of two values
type MinFunc struct{}

func (f *MinFunc) Name() string  <span class="cov8" title="1">{ return "MIN" }</span>
func (f *MinFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *MinFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *MinFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        x, err := valueToNumber(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MIN: %w", err)
        }</span>

        <span class="cov8" title="1">y, err := valueToNumber(args[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MIN: %w", err)
        }</span>

        <span class="cov8" title="1">return math.Min(x, y), nil</span>
}

// MaxFunc returns the maximum of two values
type MaxFunc struct{}

func (f *MaxFunc) Name() string  <span class="cov8" title="1">{ return "MAX" }</span>
func (f *MaxFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *MaxFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *MaxFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        x, err := valueToNumber(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MAX: %w", err)
        }</span>

        <span class="cov8" title="1">y, err := valueToNumber(args[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MAX: %w", err)
        }</span>

        <span class="cov8" title="1">return math.Max(x, y), nil</span>
}

// Date/Time Functions

// NowFunc returns the current timestamp
type NowFunc struct{}

func (f *NowFunc) Name() string  <span class="cov8" title="1">{ return "NOW" }</span>
func (f *NowFunc) MinArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *NowFunc) MaxArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *NowFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return time.Now().Format(time.RFC3339), nil
}</span>

// CurrentDateFunc returns the current date
type CurrentDateFunc struct{}

func (f *CurrentDateFunc) Name() string  <span class="cov8" title="1">{ return "CURRENT_DATE" }</span>
func (f *CurrentDateFunc) MinArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *CurrentDateFunc) MaxArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *CurrentDateFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return time.Now().Format("2006-01-02"), nil
}</span>

// CurrentTimeFunc returns the current time
type CurrentTimeFunc struct{}

func (f *CurrentTimeFunc) Name() string  <span class="cov8" title="1">{ return "CURRENT_TIME" }</span>
func (f *CurrentTimeFunc) MinArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *CurrentTimeFunc) MaxArity() int <span class="cov0" title="0">{ return 0 }</span>
func (f *CurrentTimeFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return time.Now().Format("15:04:05"), nil
}</span>

// Helper to parse date strings
func parseDate(v interface{}) (time.Time, error) <span class="cov8" title="1">{
        str, err := valueToString(v)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov8" title="1">layouts := []string{
                time.RFC3339,
                "2006-01-02",
                "2006-01-02 15:04:05",
                "2006-01-02T15:04:05",
        }

        for _, layout := range layouts </span><span class="cov8" title="1">{
                if t, err := time.Parse(layout, str); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("cannot parse date: %s", str)</span>
}

// DateTruncFunc truncates a date to the specified unit
type DateTruncFunc struct{}

func (f *DateTruncFunc) Name() string  <span class="cov8" title="1">{ return "DATE_TRUNC" }</span>
func (f *DateTruncFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DateTruncFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DateTruncFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        unit, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_TRUNC: unit: %w", err)
        }</span>

        <span class="cov8" title="1">date, err := parseDate(args[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_TRUNC: %w", err)
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(unit) </span>{
        case "year":<span class="cov8" title="1">
                return time.Date(date.Year(), 1, 1, 0, 0, 0, 0, date.Location()).Format(time.RFC3339), nil</span>
        case "month":<span class="cov8" title="1">
                return time.Date(date.Year(), date.Month(), 1, 0, 0, 0, 0, date.Location()).Format(time.RFC3339), nil</span>
        case "day":<span class="cov8" title="1">
                return time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location()).Format(time.RFC3339), nil</span>
        case "hour":<span class="cov8" title="1">
                return time.Date(date.Year(), date.Month(), date.Day(), date.Hour(), 0, 0, 0, date.Location()).Format(time.RFC3339), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("DATE_TRUNC: invalid unit: %s", unit)</span>
        }
}

// DatePartFunc extracts a part of a date
type DatePartFunc struct{}

func (f *DatePartFunc) Name() string  <span class="cov8" title="1">{ return "DATE_PART" }</span>
func (f *DatePartFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DatePartFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DatePartFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        unit, err := valueToString(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_PART: unit: %w", err)
        }</span>

        <span class="cov8" title="1">date, err := parseDate(args[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_PART: %w", err)
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(unit) </span>{
        case "year":<span class="cov8" title="1">
                return int64(date.Year()), nil</span>
        case "month":<span class="cov8" title="1">
                return int64(date.Month()), nil</span>
        case "day":<span class="cov8" title="1">
                return int64(date.Day()), nil</span>
        case "hour":<span class="cov8" title="1">
                return int64(date.Hour()), nil</span>
        case "minute":<span class="cov8" title="1">
                return int64(date.Minute()), nil</span>
        case "second":<span class="cov8" title="1">
                return int64(date.Second()), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("DATE_PART: invalid unit: %s", unit)</span>
        }
}

// DateAddFunc adds an interval to a date
type DateAddFunc struct{}

func (f *DateAddFunc) Name() string  <span class="cov8" title="1">{ return "DATE_ADD" }</span>
func (f *DateAddFunc) MinArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *DateAddFunc) MaxArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *DateAddFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_ADD: %w", err)
        }</span>

        <span class="cov8" title="1">amount, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_ADD: amount: %w", err)
        }</span>

        <span class="cov8" title="1">unit, err := valueToString(args[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_ADD: unit: %w", err)
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(unit) </span>{
        case "year":<span class="cov8" title="1">
                return date.AddDate(int(amount), 0, 0).Format(time.RFC3339), nil</span>
        case "month":<span class="cov8" title="1">
                return date.AddDate(0, int(amount), 0).Format(time.RFC3339), nil</span>
        case "day":<span class="cov8" title="1">
                return date.AddDate(0, 0, int(amount)).Format(time.RFC3339), nil</span>
        case "hour":<span class="cov8" title="1">
                return date.Add(time.Duration(amount) * time.Hour).Format(time.RFC3339), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("DATE_ADD: invalid unit: %s", unit)</span>
        }
}

// DateSubFunc subtracts an interval from a date
type DateSubFunc struct{}

func (f *DateSubFunc) Name() string  <span class="cov8" title="1">{ return "DATE_SUB" }</span>
func (f *DateSubFunc) MinArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *DateSubFunc) MaxArity() int <span class="cov0" title="0">{ return 3 }</span>
func (f *DateSubFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_SUB: %w", err)
        }</span>

        <span class="cov8" title="1">amount, err := valueToNumber(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_SUB: amount: %w", err)
        }</span>

        <span class="cov8" title="1">unit, err := valueToString(args[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATE_SUB: unit: %w", err)
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(unit) </span>{
        case "year":<span class="cov8" title="1">
                return date.AddDate(-int(amount), 0, 0).Format(time.RFC3339), nil</span>
        case "month":<span class="cov8" title="1">
                return date.AddDate(0, -int(amount), 0).Format(time.RFC3339), nil</span>
        case "day":<span class="cov8" title="1">
                return date.AddDate(0, 0, -int(amount)).Format(time.RFC3339), nil</span>
        case "hour":<span class="cov8" title="1">
                return date.Add(-time.Duration(amount) * time.Hour).Format(time.RFC3339), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("DATE_SUB: invalid unit: %s", unit)</span>
        }
}

// DateDiffFunc returns the difference between two dates in days
type DateDiffFunc struct{}

func (f *DateDiffFunc) Name() string  <span class="cov8" title="1">{ return "DATE_DIFF" }</span>
func (f *DateDiffFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DateDiffFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *DateDiffFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date1, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_DIFF: first date: %w", err)
        }</span>

        <span class="cov8" title="1">date2, err := parseDate(args[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("DATE_DIFF: second date: %w", err)
        }</span>

        <span class="cov8" title="1">diff := date1.Sub(date2)
        return int64(diff.Hours() / 24), nil</span>
}

// YearFunc extracts the year from a date
type YearFunc struct{}

func (f *YearFunc) Name() string  <span class="cov8" title="1">{ return "YEAR" }</span>
func (f *YearFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *YearFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *YearFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("YEAR: %w", err)
        }</span>
        <span class="cov8" title="1">return int64(date.Year()), nil</span>
}

// MonthFunc extracts the month from a date
type MonthFunc struct{}

func (f *MonthFunc) Name() string  <span class="cov8" title="1">{ return "MONTH" }</span>
func (f *MonthFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *MonthFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *MonthFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MONTH: %w", err)
        }</span>
        <span class="cov8" title="1">return int64(date.Month()), nil</span>
}

// Type Conversion Functions

// CastFunc converts a value to a specific type
type CastFunc struct{}

func (f *CastFunc) Name() string  <span class="cov8" title="1">{ return "CAST" }</span>
func (f *CastFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *CastFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *CastFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        value := args[0]
        typeName, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CAST: type: %w", err)
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(typeName) </span>{
        case "string":<span class="cov8" title="1">
                return valueToString(value)</span>
        case "number":<span class="cov8" title="1">
                return valueToNumber(value)</span>
        case "date":<span class="cov8" title="1">
                return parseDate(value)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("CAST: unknown type: %s", typeName)</span>
        }
}

// TryCastFunc converts a value to a specific type, returning null on error
type TryCastFunc struct{}

func (f *TryCastFunc) Name() string  <span class="cov8" title="1">{ return "TRY_CAST" }</span>
func (f *TryCastFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *TryCastFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *TryCastFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        value := args[0]
        typeName, err := valueToString(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(typeName) </span>{
        case "string":<span class="cov8" title="1">
                result, err := valueToString(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case "number":<span class="cov8" title="1">
                result, err := valueToNumber(value)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case "date":<span class="cov8" title="1">
                result, err := parseDate(value)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        default:<span class="cov8" title="1">
                return nil, nil</span>
        }
}

// ToStringFunc converts a value to a string
type ToStringFunc struct{}

func (f *ToStringFunc) Name() string  <span class="cov8" title="1">{ return "TO_STRING" }</span>
func (f *ToStringFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToStringFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToStringFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return valueToString(args[0])
}</span>

// ToNumberFunc converts a value to a number
type ToNumberFunc struct{}

func (f *ToNumberFunc) Name() string  <span class="cov8" title="1">{ return "TO_NUMBER" }</span>
func (f *ToNumberFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToNumberFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToNumberFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        return valueToNumber(args[0])
}</span>

// ToDateFunc converts a value to a date
type ToDateFunc struct{}

func (f *ToDateFunc) Name() string  <span class="cov8" title="1">{ return "TO_DATE" }</span>
func (f *ToDateFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToDateFunc) MaxArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *ToDateFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        date, err := parseDate(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return date.Format("2006-01-02"), nil</span>
}

// Conditional Functions

// CoalesceFunc returns the first non-null value
type CoalesceFunc struct{}

func (f *CoalesceFunc) Name() string  <span class="cov8" title="1">{ return "COALESCE" }</span>
func (f *CoalesceFunc) MinArity() int <span class="cov0" title="0">{ return 1 }</span>
func (f *CoalesceFunc) MaxArity() int <span class="cov0" title="0">{ return -1 }</span>
func (f *CoalesceFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        for _, arg := range args </span><span class="cov8" title="1">{
                if arg != nil </span><span class="cov8" title="1">{
                        return arg, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// NullIfFunc returns null if two values are equal, otherwise returns the first value
type NullIfFunc struct{}

func (f *NullIfFunc) Name() string  <span class="cov8" title="1">{ return "NULLIF" }</span>
func (f *NullIfFunc) MinArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *NullIfFunc) MaxArity() int <span class="cov0" title="0">{ return 2 }</span>
func (f *NullIfFunc) Evaluate(args []interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Handle nil values
        if args[0] == nil &amp;&amp; args[1] == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if args[0] == nil || args[1] == nil </span><span class="cov0" title="0">{
                return args[0], nil
        }</span>

        // Use safe comparison via compare function to avoid panic on non-comparable types
        <span class="cov8" title="1">match, err := compare(args[0], TokenEqual, args[1])
        if err != nil </span><span class="cov0" title="0">{
                // If comparison fails, values are not equal
                return args[0], nil
        }</span>

        <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return args[0], nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package query

import (
        "strings"
        "unicode"
)

// Lexer tokenizes SQL query strings
type Lexer struct {
        input string
        pos   int
        ch    rune
}

// NewLexer creates a new lexer
func NewLexer(input string) *Lexer <span class="cov8" title="1">{
        l := &amp;Lexer{input: input}
        l.readChar()
        return l
}</span>

// readChar reads the next character
func (l *Lexer) readChar() <span class="cov8" title="1">{
        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                l.ch = 0
        }</span> else<span class="cov8" title="1"> {
                l.ch = rune(l.input[l.pos])
        }</span>
        <span class="cov8" title="1">l.pos++</span>
}

// peekChar looks at the next character without advancing
func (l *Lexer) peekChar() rune <span class="cov8" title="1">{
        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return rune(l.input[l.pos])</span>
}

// skipWhitespace skips whitespace characters
func (l *Lexer) skipWhitespace() <span class="cov8" title="1">{
        for l.ch == ' ' || l.ch == '\t' || l.ch == '\n' || l.ch == '\r' </span><span class="cov8" title="1">{
                l.readChar()
        }</span>
}

// readString reads a quoted string
func (l *Lexer) readString(quote rune) string <span class="cov8" title="1">{
        var result strings.Builder
        l.readChar() // skip opening quote

        for l.ch != quote &amp;&amp; l.ch != 0 </span><span class="cov8" title="1">{
                if l.ch == '\\' </span><span class="cov8" title="1">{
                        l.readChar()
                        switch l.ch </span>{
                        case 'n':<span class="cov8" title="1">
                                result.WriteRune('\n')</span>
                        case 't':<span class="cov8" title="1">
                                result.WriteRune('\t')</span>
                        case '\\':<span class="cov0" title="0">
                                result.WriteRune('\\')</span>
                        case quote:<span class="cov8" title="1">
                                result.WriteRune(quote)</span>
                        default:<span class="cov0" title="0">
                                result.WriteRune(l.ch)</span>
                        }
                } else<span class="cov8" title="1"> {
                        result.WriteRune(l.ch)
                }</span>
                <span class="cov8" title="1">l.readChar()</span>
        }

        <span class="cov8" title="1">if l.ch == quote </span><span class="cov8" title="1">{
                l.readChar() // skip closing quote
        }</span>

        <span class="cov8" title="1">return result.String()</span>
}

// readNumber reads a number
func (l *Lexer) readNumber() string <span class="cov8" title="1">{
        var result strings.Builder

        // Handle optional leading minus sign
        if l.ch == '-' </span><span class="cov8" title="1">{
                result.WriteRune(l.ch)
                l.readChar()
        }</span>

        // Read digits and decimal point (but not additional minus signs)
        <span class="cov8" title="1">for unicode.IsDigit(l.ch) || l.ch == '.' </span><span class="cov8" title="1">{
                result.WriteRune(l.ch)
                l.readChar()
        }</span>
        <span class="cov8" title="1">return result.String()</span>
}

// readIdentifier reads an identifier or keyword (including file paths)
func (l *Lexer) readIdentifier() string <span class="cov8" title="1">{
        var result strings.Builder
        for unicode.IsLetter(l.ch) || unicode.IsDigit(l.ch) || l.ch == '_' || l.ch == '.' || l.ch == '/' || l.ch == '-' </span><span class="cov8" title="1">{
                result.WriteRune(l.ch)
                l.readChar()
        }</span>
        <span class="cov8" title="1">return result.String()</span>
}

// NextToken returns the next token
func (l *Lexer) NextToken() Token <span class="cov8" title="1">{
        l.skipWhitespace()

        var tok Token

        switch l.ch </span>{
        case 0:<span class="cov8" title="1">
                tok = Token{Type: TokenEOF, Value: ""}</span>
        case '=':<span class="cov8" title="1">
                tok = Token{Type: TokenEqual, Value: "="}
                l.readChar()</span>
        case '!':<span class="cov8" title="1">
                if l.peekChar() == '=' </span><span class="cov8" title="1">{
                        l.readChar()
                        tok = Token{Type: TokenNotEqual, Value: "!="}
                        l.readChar()
                }</span> else<span class="cov0" title="0"> {
                        tok = Token{Type: TokenError, Value: "!"}
                        l.readChar()
                }</span>
        case '&lt;':<span class="cov8" title="1">
                if l.peekChar() == '=' </span><span class="cov8" title="1">{
                        l.readChar()
                        tok = Token{Type: TokenLessEqual, Value: "&lt;="}
                        l.readChar()
                }</span> else<span class="cov8" title="1"> {
                        tok = Token{Type: TokenLess, Value: "&lt;"}
                        l.readChar()
                }</span>
        case '&gt;':<span class="cov8" title="1">
                if l.peekChar() == '=' </span><span class="cov8" title="1">{
                        l.readChar()
                        tok = Token{Type: TokenGreaterEqual, Value: "&gt;="}
                        l.readChar()
                }</span> else<span class="cov8" title="1"> {
                        tok = Token{Type: TokenGreater, Value: "&gt;"}
                        l.readChar()
                }</span>
        case '\'', '"':<span class="cov8" title="1">
                quote := l.ch
                tok = Token{Type: TokenString, Value: l.readString(quote)}</span>
        case '*':<span class="cov8" title="1">
                tok = Token{Type: TokenIdent, Value: "*"}
                l.readChar()</span>
        case ',':<span class="cov8" title="1">
                tok = Token{Type: TokenComma, Value: ","}
                l.readChar()</span>
        case '(':<span class="cov8" title="1">
                tok = Token{Type: TokenLeftParen, Value: "("}
                l.readChar()</span>
        case ')':<span class="cov8" title="1">
                tok = Token{Type: TokenRightParen, Value: ")"}
                l.readChar()</span>
        default:<span class="cov8" title="1">
                if unicode.IsDigit(l.ch) || l.ch == '-' </span><span class="cov8" title="1">{
                        value := l.readNumber()
                        // Validate that a standalone minus sign is not treated as a number
                        if value == "-" </span><span class="cov0" title="0">{
                                tok = Token{Type: TokenError, Value: "-"}
                        }</span> else<span class="cov8" title="1"> {
                                tok = Token{Type: TokenNumber, Value: value}
                        }</span>
                } else<span class="cov8" title="1"> if unicode.IsLetter(l.ch) || l.ch == '_' </span><span class="cov8" title="1">{
                        value := l.readIdentifier()
                        tok = Token{Type: identifierType(value), Value: value}
                }</span> else<span class="cov0" title="0"> {
                        tok = Token{Type: TokenError, Value: string(l.ch)}
                        l.readChar()
                }</span>
        }

        <span class="cov8" title="1">return tok</span>
}

// identifierType determines if an identifier is a keyword
func identifierType(ident string) TokenType <span class="cov8" title="1">{
        keywords := map[string]TokenType{
                "select":    TokenSelect,
                "SELECT":    TokenSelect,
                "from":      TokenFrom,
                "FROM":      TokenFrom,
                "where":     TokenWhere,
                "WHERE":     TokenWhere,
                "and":       TokenAnd,
                "AND":       TokenAnd,
                "or":        TokenOr,
                "OR":        TokenOr,
                "as":        TokenAs,
                "AS":        TokenAs,
                "group":     TokenGroup,
                "GROUP":     TokenGroup,
                "by":        TokenBy,
                "BY":        TokenBy,
                "having":    TokenHaving,
                "HAVING":    TokenHaving,
                "order":     TokenOrder,
                "ORDER":     TokenOrder,
                "asc":       TokenAsc,
                "ASC":       TokenAsc,
                "desc":      TokenDesc,
                "DESC":      TokenDesc,
                "limit":     TokenLimit,
                "LIMIT":     TokenLimit,
                "offset":    TokenOffset,
                "OFFSET":    TokenOffset,
                "in":        TokenIn,
                "IN":        TokenIn,
                "like":      TokenLike,
                "LIKE":      TokenLike,
                "between":   TokenBetween,
                "BETWEEN":   TokenBetween,
                "is":        TokenIs,
                "IS":        TokenIs,
                "not":       TokenNot,
                "NOT":       TokenNot,
                "null":      TokenNull,
                "NULL":      TokenNull,
                "distinct":  TokenDistinct,
                "DISTINCT":  TokenDistinct,
                "case":      TokenCase,
                "CASE":      TokenCase,
                "when":      TokenWhen,
                "WHEN":      TokenWhen,
                "then":      TokenThen,
                "THEN":      TokenThen,
                "else":      TokenElse,
                "ELSE":      TokenElse,
                "end":       TokenEnd,
                "END":       TokenEnd,
                "over":      TokenOver,
                "OVER":      TokenOver,
                "partition": TokenPartition,
                "PARTITION": TokenPartition,
                "rows":      TokenRows,
                "ROWS":      TokenRows,
                "range":     TokenRange,
                "RANGE":     TokenRange,
                "with":      TokenWith,
                "WITH":      TokenWith,
                "recursive": TokenRecursive,
                "RECURSIVE": TokenRecursive,
                "exists":    TokenExists,
                "EXISTS":    TokenExists,
                "join":      TokenJoin,
                "JOIN":      TokenJoin,
                "inner":     TokenInner,
                "INNER":     TokenInner,
                "left":      TokenLeft,
                "LEFT":      TokenLeft,
                "right":     TokenRight,
                "RIGHT":     TokenRight,
                "full":      TokenFull,
                "FULL":      TokenFull,
                "outer":     TokenOuter,
                "OUTER":     TokenOuter,
                "cross":     TokenCross,
                "CROSS":     TokenCross,
                "on":        TokenOn,
                "ON":        TokenOn,
                "true":      TokenBool,
                "TRUE":      TokenBool,
                "false":     TokenBool,
                "FALSE":     TokenBool,
        }

        if tokType, ok := keywords[ident]; ok </span><span class="cov8" title="1">{
                return tokType
        }</span>
        <span class="cov8" title="1">return TokenIdent</span>
}

// Tokenize returns all tokens from the input
func Tokenize(input string) []Token <span class="cov8" title="1">{
        lexer := NewLexer(input)
        var tokens []Token

        for </span><span class="cov8" title="1">{
                tok := lexer.NextToken()
                tokens = append(tokens, tok)
                if tok.Type == TokenEOF || tok.Type == TokenError </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return tokens</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package query

import (
        "fmt"
        "strconv"
        "strings"
)

// Parser parses SQL queries into AST
type Parser struct {
        tokens       []Token
        pos          int
        depthCounter *ExpressionDepthCounter
}

// NewParser creates a new parser
func NewParser(tokens []Token) *Parser <span class="cov8" title="1">{
        return &amp;Parser{
                tokens:       tokens,
                pos:          0,
                depthCounter: NewExpressionDepthCounter(),
        }
}</span>

// current returns the current token
func (p *Parser) current() Token <span class="cov8" title="1">{
        if p.pos &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return Token{Type: TokenEOF, Value: ""}
        }</span>
        <span class="cov8" title="1">return p.tokens[p.pos]</span>
}

// peek returns the next token without advancing
func (p *Parser) peek() Token <span class="cov8" title="1">{
        if p.pos+1 &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                return Token{Type: TokenEOF, Value: ""}
        }</span>
        <span class="cov8" title="1">return p.tokens[p.pos+1]</span>
}

// advance moves to the next token
func (p *Parser) advance() <span class="cov8" title="1">{
        p.pos++
}</span>

// expect checks if current token matches expected type and advances
func (p *Parser) expect(tokType TokenType) error <span class="cov8" title="1">{
        if p.current().Type != tokType </span><span class="cov8" title="1">{
                return fmt.Errorf("expected %v, got %v", tokType, p.current().Type)
        }</span>
        <span class="cov8" title="1">p.advance()
        return nil</span>
}

// Parse parses a SQL query
func Parse(query string) (*Query, error) <span class="cov8" title="1">{
        // Validate query length
        if err := ValidateQuery(query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tokens := Tokenize(query)

        // Validate token count
        if err := ValidateTokens(tokens); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">parser := NewParser(tokens)
        q, err := parser.parseQuery()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Validate that we consumed all tokens (should be at EOF)
        <span class="cov8" title="1">if parser.current().Type == TokenError </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid character in query: %s", parser.current().Value)
        }</span>
        <span class="cov8" title="1">if parser.current().Type != TokenEOF </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected trailing tokens after query: %s", parser.current().Value)
        }</span>

        <span class="cov8" title="1">return q, nil</span>
}

// parseQuery parses: [WITH cte AS (...)] SELECT col1, col2, ... FROM table WHERE expr
func (p *Parser) parseQuery() (*Query, error) <span class="cov8" title="1">{
        var ctes []CTE

        // Parse WITH clause (optional)
        if p.current().Type == TokenWith </span><span class="cov8" title="1">{
                var err error
                ctes, err = p.parseWithClause()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        // Parse SELECT
        <span class="cov8" title="1">if err := p.expect(TokenSelect); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("query must start with SELECT (or WITH): %w", err)
        }</span>

        // Check for DISTINCT
        <span class="cov8" title="1">distinct := false
        if p.current().Type == TokenDistinct </span><span class="cov8" title="1">{
                distinct = true
                p.advance()
        }</span>

        // Parse SELECT list
        <span class="cov8" title="1">selectList, err := p.parseSelectList()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse SELECT list: %w", err)
        }</span>

        // Parse FROM
        <span class="cov8" title="1">if err := p.expect(TokenFrom); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected FROM after SELECT list: %w", err)
        }</span>

        // Initialize query
        <span class="cov8" title="1">q := &amp;Query{
                CTEs:       ctes,
                SelectList: selectList,
                Distinct:   distinct,
        }

        // Parse FROM source (table name, subquery, or CTE reference)
        if p.current().Type == TokenLeftParen </span><span class="cov8" title="1">{
                // Subquery in FROM clause
                p.advance() // consume (
                subquery, err := p.parseQuery()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse subquery in FROM: %w", err)
                }</span>
                <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ) after subquery: %w", err)
                }</span>
                <span class="cov8" title="1">q.Subquery = subquery

                // Parse optional alias for subquery
                if p.current().Type == TokenAs </span><span class="cov0" title="0">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if p.current().Type == TokenIdent </span><span class="cov0" title="0">{
                        q.TableAlias = p.current().Value
                        p.advance()
                }</span>
        } else<span class="cov8" title="1"> {
                // Table name or CTE reference (may include glob patterns like 'data/*.parquet')
                tableName := p.current().Value
                if p.current().Type != TokenIdent &amp;&amp; p.current().Type != TokenString </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected table name or subquery after FROM")
                }</span>
                <span class="cov8" title="1">p.advance()

                // Validate table name (unless it's a CTE reference or glob pattern)
                isCTE := false
                for _, cte := range ctes </span><span class="cov8" title="1">{
                        if cte.Name == tableName </span><span class="cov8" title="1">{
                                isCTE = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isCTE </span><span class="cov8" title="1">{
                        // Allow glob patterns (*, ?) without strict validation
                        if err := ValidateTableName(tableName); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">q.TableName = tableName

                // Parse optional alias for table
                if p.current().Type == TokenAs </span><span class="cov0" title="0">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if p.current().Type == TokenIdent </span><span class="cov8" title="1">{
                        q.TableAlias = p.current().Value
                        p.advance()
                }</span>
        }

        // Parse JOIN clauses (optional, can be multiple)
        <span class="cov8" title="1">for p.current().Type == TokenJoin || p.current().Type == TokenInner ||
                p.current().Type == TokenLeft || p.current().Type == TokenRight ||
                p.current().Type == TokenFull || p.current().Type == TokenCross </span><span class="cov8" title="1">{

                join, err := p.parseJoin(ctes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse JOIN: %w", err)
                }</span>
                <span class="cov8" title="1">q.Joins = append(q.Joins, *join)</span>
        }

        // Parse WHERE clause (optional)
        <span class="cov8" title="1">if p.current().Type == TokenWhere </span><span class="cov8" title="1">{
                p.advance()
                expr, err := p.parseOr()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.Filter = expr</span>
        }

        // Parse GROUP BY clause (optional)
        <span class="cov8" title="1">if p.current().Type == TokenGroup </span><span class="cov8" title="1">{
                groupBy, err := p.parseGroupBy()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.GroupBy = groupBy</span>
        }

        // Parse HAVING clause (optional, only valid with GROUP BY)
        <span class="cov8" title="1">if p.current().Type == TokenHaving </span><span class="cov8" title="1">{
                if len(q.GroupBy) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("HAVING clause requires GROUP BY")
                }</span>
                <span class="cov8" title="1">p.advance()
                expr, err := p.parseOr()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.Having = expr</span>
        }

        // Parse ORDER BY clause (optional)
        <span class="cov8" title="1">if p.current().Type == TokenOrder </span><span class="cov8" title="1">{
                orderBy, err := p.parseOrderBy()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.OrderBy = orderBy</span>
        }

        // Parse LIMIT clause (optional)
        <span class="cov8" title="1">if p.current().Type == TokenLimit </span><span class="cov8" title="1">{
                limit, err := p.parseLimit()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.Limit = limit</span>
        }

        // Parse OFFSET clause (optional)
        <span class="cov8" title="1">if p.current().Type == TokenOffset </span><span class="cov8" title="1">{
                offset, err := p.parseOffset()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">q.Offset = offset</span>
        }

        <span class="cov8" title="1">return q, nil</span>
}

// parseJoin parses a JOIN clause
func (p *Parser) parseJoin(ctes []CTE) (*Join, error) <span class="cov8" title="1">{
        join := &amp;Join{}

        // Determine join type
        switch p.current().Type </span>{
        case TokenCross:<span class="cov8" title="1">
                join.Type = JoinCross
                p.advance()
                if err := p.expect(TokenJoin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case TokenInner:<span class="cov8" title="1">
                join.Type = JoinInner
                p.advance()
                if err := p.expect(TokenJoin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case TokenLeft:<span class="cov8" title="1">
                join.Type = JoinLeft
                p.advance()
                // Optional OUTER keyword
                if p.current().Type == TokenOuter </span><span class="cov8" title="1">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if err := p.expect(TokenJoin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case TokenRight:<span class="cov8" title="1">
                join.Type = JoinRight
                p.advance()
                // Optional OUTER keyword
                if p.current().Type == TokenOuter </span><span class="cov0" title="0">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if err := p.expect(TokenJoin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case TokenFull:<span class="cov8" title="1">
                join.Type = JoinFull
                p.advance()
                // Optional OUTER keyword
                if p.current().Type == TokenOuter </span><span class="cov8" title="1">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if err := p.expect(TokenJoin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case TokenJoin:<span class="cov8" title="1">
                // Plain JOIN defaults to INNER JOIN
                join.Type = JoinInner
                p.advance()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected JOIN keyword")</span>
        }

        // Parse joined table or subquery
        <span class="cov8" title="1">if p.current().Type == TokenLeftParen </span><span class="cov8" title="1">{
                // Subquery
                p.advance() // consume (
                subquery, err := p.parseQuery()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse subquery in JOIN: %w", err)
                }</span>
                <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ) after subquery: %w", err)
                }</span>
                <span class="cov8" title="1">join.Subquery = subquery

                // Parse optional alias for subquery
                if p.current().Type == TokenAs </span><span class="cov0" title="0">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if p.current().Type == TokenIdent </span><span class="cov8" title="1">{
                        join.Alias = p.current().Value
                        p.advance()
                }</span>
        } else<span class="cov8" title="1"> {
                // Table name or CTE reference
                tableName := p.current().Value
                if p.current().Type != TokenIdent &amp;&amp; p.current().Type != TokenString </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected table name or subquery after JOIN")
                }</span>
                <span class="cov8" title="1">p.advance()

                // Validate table name (unless it's a CTE reference)
                isCTE := false
                for _, cte := range ctes </span><span class="cov0" title="0">{
                        if cte.Name == tableName </span><span class="cov0" title="0">{
                                isCTE = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isCTE </span><span class="cov8" title="1">{
                        if err := ValidateTableName(tableName); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">join.TableName = tableName

                // Parse optional alias for table
                if p.current().Type == TokenAs </span><span class="cov0" title="0">{
                        p.advance()
                }</span>
                <span class="cov8" title="1">if p.current().Type == TokenIdent </span><span class="cov8" title="1">{
                        join.Alias = p.current().Value
                        p.advance()
                }</span>
        }

        // Parse ON clause (required for all join types except CROSS JOIN)
        <span class="cov8" title="1">if join.Type != JoinCross </span><span class="cov8" title="1">{
                if err := p.expect(TokenOn); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ON clause after JOIN table: %w", err)
                }</span>
                <span class="cov8" title="1">condition, err := p.parseOr()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse JOIN condition: %w", err)
                }</span>
                <span class="cov8" title="1">join.Condition = condition</span>
        }

        <span class="cov8" title="1">return join, nil</span>
}

// parseOr parses OR expressions (lowest precedence)
func (p *Parser) parseOr() (Expression, error) <span class="cov8" title="1">{
        if err := p.depthCounter.Enter(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer p.depthCounter.Exit()

        left, err := p.parseAnd()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for p.current().Type == TokenOr </span><span class="cov8" title="1">{
                p.advance()
                right, err := p.parseAnd()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">left = &amp;BinaryExpr{
                        Left:     left,
                        Operator: TokenOr,
                        Right:    right,
                }</span>
        }

        <span class="cov8" title="1">return left, nil</span>
}

// parseAnd parses AND expressions (higher precedence than OR)
func (p *Parser) parseAnd() (Expression, error) <span class="cov8" title="1">{
        if err := p.depthCounter.Enter(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer p.depthCounter.Exit()

        left, err := p.parseComparison()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for p.current().Type == TokenAnd </span><span class="cov8" title="1">{
                p.advance()
                right, err := p.parseComparison()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">left = &amp;BinaryExpr{
                        Left:     left,
                        Operator: TokenAnd,
                        Right:    right,
                }</span>
        }

        <span class="cov8" title="1">return left, nil</span>
}

// parseSelectList parses the SELECT list (columns, expressions, aliases)
func (p *Parser) parseSelectList() ([]SelectItem, error) <span class="cov8" title="1">{
        var items []SelectItem

        for </span><span class="cov8" title="1">{
                item, err := p.parseSelectItem()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, item)

                // Check for comma (more items)
                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }

                // No comma, we're done with the SELECT list
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">return items, nil</span>
}

// parseSelectItem parses a single SELECT item (column, function, or expression with optional alias)
func (p *Parser) parseSelectItem() (SelectItem, error) <span class="cov8" title="1">{
        var item SelectItem

        // Parse the expression (column or function call)
        expr, err := p.parseSelectExpression()
        if err != nil </span><span class="cov8" title="1">{
                return item, err
        }</span>
        <span class="cov8" title="1">item.Expr = expr

        // Check for AS alias
        if p.current().Type == TokenAs </span><span class="cov8" title="1">{
                p.advance()
                if p.current().Type != TokenIdent </span><span class="cov0" title="0">{
                        return item, fmt.Errorf("expected alias name after AS")
                }</span>
                <span class="cov8" title="1">item.Alias = p.current().Value
                p.advance()</span>
        } else<span class="cov8" title="1"> if p.current().Type == TokenIdent &amp;&amp; p.current().Value != "*" </span><span class="cov0" title="0">{
                // Check for implicit alias (column name without AS)
                // But only if it's not a keyword or operator
                if !isKeyword(p.current().Value) </span><span class="cov0" title="0">{
                        item.Alias = p.current().Value
                        p.advance()
                }</span>
        }

        <span class="cov8" title="1">return item, nil</span>
}

// parseSelectExpression parses a select expression (column reference, function call, literal, CASE, or subquery)
func (p *Parser) parseSelectExpression() (SelectExpression, error) <span class="cov8" title="1">{
        // Check for CASE expression
        if p.current().Type == TokenCase </span><span class="cov8" title="1">{
                return p.parseCaseExpression()
        }</span>

        // Check for scalar subquery (starts with opening paren)
        <span class="cov8" title="1">if p.current().Type == TokenLeftParen </span><span class="cov8" title="1">{
                // Look ahead to see if it's a subquery (SELECT or WITH)
                nextPos := p.pos + 1
                if nextPos &lt; len(p.tokens) &amp;&amp; (p.tokens[nextPos].Type == TokenSelect || p.tokens[nextPos].Type == TokenWith) </span><span class="cov8" title="1">{
                        return p.parseScalarSubquery()
                }</span>
        }

        // Check for aggregate or regular function call (identifier followed by left paren)
        <span class="cov8" title="1">if p.current().Type == TokenIdent &amp;&amp; p.peek().Type == TokenLeftParen </span><span class="cov8" title="1">{
                // Check if it's an aggregate function
                funcName := strings.ToUpper(p.current().Value)
                if isAggregateFunction(funcName) </span><span class="cov8" title="1">{
                        return p.parseAggregateFunction()
                }</span>
                // Check if it's a window function
                <span class="cov8" title="1">if isWindowFunction(funcName) </span><span class="cov8" title="1">{
                        return p.parseWindowFunction()
                }</span>
                <span class="cov8" title="1">return p.parseFunctionCall()</span>
        }

        // Check for literals (numbers, strings, bools)
        <span class="cov8" title="1">switch p.current().Type </span>{
        case TokenNumber:<span class="cov8" title="1">
                numStr := p.current().Value
                p.advance()
                // Try to parse as int first, then float
                if intVal, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return &amp;LiteralExpr{Value: intVal}, nil
                }</span> else<span class="cov0" title="0"> if floatVal, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                        return &amp;LiteralExpr{Value: floatVal}, nil
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid number: %s", numStr)
                }</span>
        case TokenString:<span class="cov8" title="1">
                str := p.current().Value
                p.advance()
                return &amp;LiteralExpr{Value: str}, nil</span>
        case TokenBool:<span class="cov0" title="0">
                b := strings.ToLower(p.current().Value) == "true"
                p.advance()
                return &amp;LiteralExpr{Value: b}, nil</span>
        }

        // Otherwise, it's a column reference
        <span class="cov8" title="1">if p.current().Type != TokenIdent </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected column name, literal, or function call, got %v", p.current().Type)
        }</span>

        <span class="cov8" title="1">column := p.current().Value
        p.advance()

        return &amp;ColumnRef{Column: column}, nil</span>
}

// parseFunctionCall parses a function call
func (p *Parser) parseFunctionCall() (SelectExpression, error) <span class="cov8" title="1">{
        funcName := p.current().Value
        p.advance() // skip function name

        if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after function name: %w", err)
        }</span>

        <span class="cov8" title="1">var args []SelectExpression

        // Check for empty argument list
        if p.current().Type == TokenRightParen </span><span class="cov8" title="1">{
                p.advance()
                return &amp;FunctionCall{Name: funcName, Args: args}, nil
        }</span>

        // Parse arguments
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                arg, err := p.parseSelectExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">args = append(args, arg)

                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }

                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected ')' after function arguments: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FunctionCall{Name: funcName, Args: args}, nil</span>
}

// parseWindowFunction parses a window function call
func (p *Parser) parseWindowFunction() (SelectExpression, error) <span class="cov8" title="1">{
        funcName := p.current().Value
        p.advance() // skip function name

        if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after window function name: %w", err)
        }</span>

        <span class="cov8" title="1">var args []SelectExpression

        // Check for empty argument list
        if p.current().Type != TokenRightParen </span><span class="cov8" title="1">{
                // Parse arguments
                for </span><span class="cov8" title="1">{
                        arg, err := p.parseSelectExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">args = append(args, arg)

                        if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">break</span>
                }
        }

        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after window function arguments: %w", err)
        }</span>

        // Window functions must have an OVER clause
        <span class="cov8" title="1">if p.current().Type != TokenOver </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("window function %s requires OVER clause", funcName)
        }</span>
        <span class="cov8" title="1">p.advance() // skip OVER

        // Parse window specification
        windowSpec, err := p.parseWindowSpec()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse window specification: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;WindowExpr{
                Function: strings.ToUpper(funcName),
                Args:     args,
                Window:   windowSpec,
        }, nil</span>
}

// parseWindowSpec parses a window specification (PARTITION BY, ORDER BY, frame)
func (p *Parser) parseWindowSpec() (*WindowSpec, error) <span class="cov8" title="1">{
        if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after OVER: %w", err)
        }</span>

        <span class="cov8" title="1">spec := &amp;WindowSpec{}

        // Parse PARTITION BY (optional)
        if p.current().Type == TokenPartition </span><span class="cov8" title="1">{
                p.advance()
                if err := p.expect(TokenBy); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected BY after PARTITION: %w", err)
                }</span>

                // Parse partition columns
                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        if p.current().Type != TokenIdent </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected column name in PARTITION BY")
                        }</span>
                        <span class="cov8" title="1">spec.PartitionBy = append(spec.PartitionBy, p.current().Value)
                        p.advance()

                        if p.current().Type == TokenComma </span><span class="cov0" title="0">{
                                p.advance()
                                continue</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }

        // Parse ORDER BY (optional)
        <span class="cov8" title="1">if p.current().Type == TokenOrder </span><span class="cov8" title="1">{
                p.advance()
                if err := p.expect(TokenBy); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected BY after ORDER: %w", err)
                }</span>

                <span class="cov8" title="1">orderBy, err := p.parseOrderByList()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse ORDER BY in window: %w", err)
                }</span>
                <span class="cov8" title="1">spec.OrderBy = orderBy</span>
        }

        // Parse frame specification (optional)
        <span class="cov8" title="1">if p.current().Type == TokenRows || p.current().Type == TokenRange </span><span class="cov8" title="1">{
                frame, err := p.parseWindowFrame()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse window frame: %w", err)
                }</span>
                <span class="cov8" title="1">spec.Frame = frame</span>
        }

        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after window specification: %w", err)
        }</span>

        <span class="cov8" title="1">return spec, nil</span>
}

// parseWindowFrame parses a window frame specification (ROWS/RANGE ...)
func (p *Parser) parseWindowFrame() (*WindowFrame, error) <span class="cov8" title="1">{
        frame := &amp;WindowFrame{}

        // Parse frame type (ROWS or RANGE)
        if p.current().Type == TokenRows </span><span class="cov8" title="1">{
                frame.Type = FrameTypeRows
        }</span> else<span class="cov8" title="1"> if p.current().Type == TokenRange </span><span class="cov8" title="1">{
                frame.Type = FrameTypeRange
        }</span> else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("expected ROWS or RANGE")
        }</span>
        <span class="cov8" title="1">p.advance()

        // For simplicity, we'll support:
        // - UNBOUNDED PRECEDING
        // - CURRENT ROW
        // - n PRECEDING
        // - n FOLLOWING
        // - UNBOUNDED FOLLOWING
        // - BETWEEN &lt;bound&gt; AND &lt;bound&gt;

        // Check for BETWEEN syntax
        if p.current().Type == TokenBetween </span><span class="cov8" title="1">{
                p.advance()

                // Parse start bound
                startBound, err := p.parseFrameBound()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse frame start bound: %w", err)
                }</span>
                <span class="cov8" title="1">frame.Start = startBound

                // Expect AND
                if err := p.expect(TokenAnd); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected AND in BETWEEN frame clause: %w", err)
                }</span>

                // Parse end bound
                <span class="cov8" title="1">endBound, err := p.parseFrameBound()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse frame end bound: %w", err)
                }</span>
                <span class="cov8" title="1">frame.End = endBound</span>
        } else<span class="cov8" title="1"> {
                // Single bound syntax (implies BETWEEN bound AND CURRENT ROW)
                bound, err := p.parseFrameBound()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse frame bound: %w", err)
                }</span>
                <span class="cov8" title="1">frame.Start = bound
                frame.End = FrameBound{Type: BoundCurrentRow}</span>
        }

        <span class="cov8" title="1">return frame, nil</span>
}

// parseFrameBound parses a single frame bound
func (p *Parser) parseFrameBound() (FrameBound, error) <span class="cov8" title="1">{
        var bound FrameBound

        // Check for UNBOUNDED
        if strings.ToUpper(p.current().Value) == "UNBOUNDED" </span><span class="cov8" title="1">{
                p.advance()

                if strings.ToUpper(p.current().Value) == "PRECEDING" </span><span class="cov8" title="1">{
                        bound.Type = BoundUnboundedPreceding
                        p.advance()
                }</span> else<span class="cov8" title="1"> if strings.ToUpper(p.current().Value) == "FOLLOWING" </span><span class="cov8" title="1">{
                        bound.Type = BoundUnboundedFollowing
                        p.advance()
                }</span> else<span class="cov8" title="1"> {
                        return bound, fmt.Errorf("expected PRECEDING or FOLLOWING after UNBOUNDED")
                }</span>

                <span class="cov8" title="1">return bound, nil</span>
        }

        // Check for CURRENT ROW
        <span class="cov8" title="1">if strings.ToUpper(p.current().Value) == "CURRENT" </span><span class="cov8" title="1">{
                p.advance()
                if strings.ToUpper(p.current().Value) != "ROW" </span><span class="cov8" title="1">{
                        return bound, fmt.Errorf("expected ROW after CURRENT")
                }</span>
                <span class="cov8" title="1">p.advance()
                bound.Type = BoundCurrentRow
                return bound, nil</span>
        }

        // Check for n PRECEDING / n FOLLOWING
        <span class="cov8" title="1">if p.current().Type == TokenNumber </span><span class="cov8" title="1">{
                offset, err := strconv.ParseInt(p.current().Value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return bound, fmt.Errorf("invalid offset in frame bound: %w", err)
                }</span>
                <span class="cov8" title="1">bound.Offset = offset
                p.advance()

                if strings.ToUpper(p.current().Value) == "PRECEDING" </span><span class="cov8" title="1">{
                        bound.Type = BoundOffsetPreceding
                        p.advance()
                }</span> else<span class="cov8" title="1"> if strings.ToUpper(p.current().Value) == "FOLLOWING" </span><span class="cov8" title="1">{
                        bound.Type = BoundOffsetFollowing
                        p.advance()
                }</span> else<span class="cov8" title="1"> {
                        return bound, fmt.Errorf("expected PRECEDING or FOLLOWING after offset")
                }</span>

                <span class="cov8" title="1">return bound, nil</span>
        }

        <span class="cov8" title="1">return bound, fmt.Errorf("invalid frame bound")</span>
}

// isKeyword checks if a string is a SQL keyword
func isKeyword(s string) bool <span class="cov0" title="0">{
        keywords := map[string]bool{
                "select": true, "SELECT": true,
                "from": true, "FROM": true,
                "where": true, "WHERE": true,
                "and": true, "AND": true,
                "or": true, "OR": true,
                "as": true, "AS": true,
                "group": true, "GROUP": true,
                "by": true, "BY": true,
                "having": true, "HAVING": true,
                "order": true, "ORDER": true,
                "asc": true, "ASC": true,
                "desc": true, "DESC": true,
                "limit": true, "LIMIT": true,
                "offset": true, "OFFSET": true,
                "in": true, "IN": true,
                "like": true, "LIKE": true,
                "between": true, "BETWEEN": true,
                "is": true, "IS": true,
                "not": true, "NOT": true,
                "null": true, "NULL": true,
                "distinct": true, "DISTINCT": true,
                "over": true, "OVER": true,
                "partition": true, "PARTITION": true,
                "rows": true, "ROWS": true,
                "range": true, "RANGE": true,
        }
        return keywords[s]
}</span>

// isAggregateFunction checks if a function name is an aggregate function
func isAggregateFunction(name string) bool <span class="cov8" title="1">{
        aggregates := map[string]bool{
                "COUNT": true,
                "SUM":   true,
                "AVG":   true,
                "MIN":   true,
                "MAX":   true,
        }
        return aggregates[strings.ToUpper(name)]
}</span>

// isWindowFunction checks if a function name is a window function
func isWindowFunction(name string) bool <span class="cov8" title="1">{
        windowFuncs := map[string]bool{
                "ROW_NUMBER":  true,
                "RANK":        true,
                "DENSE_RANK":  true,
                "NTILE":       true,
                "FIRST_VALUE": true,
                "LAST_VALUE":  true,
                "NTH_VALUE":   true,
                "LAG":         true,
                "LEAD":        true,
        }
        return windowFuncs[strings.ToUpper(name)]
}</span>

// parseAggregateFunction parses an aggregate function call
func (p *Parser) parseAggregateFunction() (SelectExpression, error) <span class="cov8" title="1">{
        funcName := strings.ToUpper(p.current().Value)
        p.advance() // skip function name

        if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after aggregate function: %w", err)
        }</span>

        <span class="cov8" title="1">var arg SelectExpression

        // Check for COUNT(*)
        if funcName == "COUNT" &amp;&amp; p.current().Type == TokenIdent &amp;&amp; p.current().Value == "*" </span><span class="cov8" title="1">{
                p.advance()
                arg = nil // COUNT(*) has no argument
        }</span> else<span class="cov8" title="1"> {
                // Parse the argument expression
                argExpr, err := p.parseSelectExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse aggregate function argument: %w", err)
                }</span>
                <span class="cov8" title="1">arg = argExpr</span>
        }

        // Check if MIN/MAX has multiple arguments (scalar function form)
        <span class="cov8" title="1">if (funcName == "MIN" || funcName == "MAX") &amp;&amp; p.current().Type == TokenComma </span><span class="cov0" title="0">{
                // Parse as scalar function with multiple arguments
                args := []SelectExpression{arg}
                for p.current().Type == TokenComma </span><span class="cov0" title="0">{
                        p.advance() // skip comma
                        nextArg, err := p.parseSelectExpression()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse function argument: %w", err)
                        }</span>
                        <span class="cov0" title="0">args = append(args, nextArg)</span>
                }

                <span class="cov0" title="0">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ')' after function arguments: %w", err)
                }</span>

                <span class="cov0" title="0">return &amp;FunctionCall{Name: funcName, Args: args}, nil</span>
        }

        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after aggregate function argument: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;AggregateExpr{
                Function: funcName,
                Arg:      arg,
                Distinct: false,
        }, nil</span>
}

// parseCaseExpression parses a CASE expression
func (p *Parser) parseCaseExpression() (SelectExpression, error) <span class="cov8" title="1">{
        // Expect CASE
        if err := p.expect(TokenCase); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var whenClauses []WhenClause

        // Parse WHEN clauses
        for p.current().Type == TokenWhen </span><span class="cov8" title="1">{
                p.advance() // skip WHEN

                // Parse the condition (a WHERE-like expression with AND/OR support)
                condition, err := p.parseOr()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse CASE WHEN condition: %w", err)
                }</span>

                // Expect THEN
                <span class="cov8" title="1">if err := p.expect(TokenThen); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected THEN after WHEN condition: %w", err)
                }</span>

                // Parse the result expression
                <span class="cov8" title="1">result, err := p.parseSelectExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse CASE THEN result: %w", err)
                }</span>

                <span class="cov8" title="1">whenClauses = append(whenClauses, WhenClause{
                        Condition: condition,
                        Result:    result,
                })</span>
        }

        // Check for at least one WHEN clause
        <span class="cov8" title="1">if len(whenClauses) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("CASE expression must have at least one WHEN clause")
        }</span>

        // Parse optional ELSE clause
        <span class="cov8" title="1">var elseExpr SelectExpression
        if p.current().Type == TokenElse </span><span class="cov8" title="1">{
                p.advance() // skip ELSE

                var err error
                elseExpr, err = p.parseSelectExpression()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse CASE ELSE result: %w", err)
                }</span>
        }

        // Expect END
        <span class="cov8" title="1">if err := p.expect(TokenEnd); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected END after CASE expression: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;CaseExpr{
                WhenClauses: whenClauses,
                ElseExpr:    elseExpr,
        }, nil</span>
}

// parseGroupBy parses the GROUP BY clause
func (p *Parser) parseGroupBy() ([]string, error) <span class="cov8" title="1">{
        // Expect GROUP
        if err := p.expect(TokenGroup); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect BY
        <span class="cov8" title="1">if err := p.expect(TokenBy); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected BY after GROUP: %w", err)
        }</span>

        <span class="cov8" title="1">var columns []string

        // Parse column list
        for </span><span class="cov8" title="1">{
                if p.current().Type != TokenIdent </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected column name in GROUP BY, got %v", p.current().Type)
                }</span>

                <span class="cov8" title="1">column := p.current().Value
                if err := ValidateColumnName(column); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">columns = append(columns, column)
                p.advance()

                // Check for comma (more columns)
                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }

                // No comma, we're done
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if len(columns) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GROUP BY requires at least one column")
        }</span>

        <span class="cov8" title="1">return columns, nil</span>
}

// parseComparison parses comparison expressions (including IN, LIKE, BETWEEN, IS NULL)
func (p *Parser) parseComparison() (Expression, error) <span class="cov8" title="1">{
        // Check for EXISTS (doesn't start with column)
        if p.current().Type == TokenExists || (p.current().Type == TokenNot &amp;&amp; p.peek().Type == TokenExists) </span><span class="cov8" title="1">{
                return p.parseExistsExpr()
        }</span>

        // Check for scalar subquery (comparison with subquery)
        // This could be a subquery, but it's not common syntax, so we'll skip for now
        // Most scalar subqueries appear on the right side of comparison

        // Parse column name
        <span class="cov8" title="1">if p.current().Type != TokenIdent </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected column name, got %v", p.current().Type)
        }</span>
        <span class="cov8" title="1">column := p.current().Value

        // Validate column name length
        if err := ValidateColumnName(column); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">p.advance()

        // Check for special operators first
        switch p.current().Type </span>{
        case TokenIn:<span class="cov8" title="1">
                return p.parseInExpr(column)</span>
        case TokenNot:<span class="cov8" title="1">
                // Could be "NOT IN", "NOT LIKE", "NOT BETWEEN"
                p.advance()
                switch p.current().Type </span>{
                case TokenIn:<span class="cov8" title="1">
                        expr, err := p.parseInExpr(column)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // Handle both InExpr and InSubqueryExpr
                        <span class="cov8" title="1">switch e := expr.(type) </span>{
                        case *InExpr:<span class="cov8" title="1">
                                e.Negate = true</span>
                        case *InSubqueryExpr:<span class="cov8" title="1">
                                e.Negate = true</span>
                        }
                        <span class="cov8" title="1">return expr, nil</span>
                case TokenLike:<span class="cov8" title="1">
                        expr, err := p.parseLikeExpr(column)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if likeExpr, ok := expr.(*LikeExpr); ok </span><span class="cov8" title="1">{
                                likeExpr.Negate = true
                        }</span>
                        <span class="cov8" title="1">return expr, nil</span>
                case TokenBetween:<span class="cov8" title="1">
                        expr, err := p.parseBetweenExpr(column)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if betweenExpr, ok := expr.(*BetweenExpr); ok </span><span class="cov8" title="1">{
                                betweenExpr.Negate = true
                        }</span>
                        <span class="cov8" title="1">return expr, nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("expected IN, LIKE, or BETWEEN after NOT, got %v", p.current().Type)</span>
                }
        case TokenLike:<span class="cov8" title="1">
                return p.parseLikeExpr(column)</span>
        case TokenBetween:<span class="cov8" title="1">
                return p.parseBetweenExpr(column)</span>
        case TokenIs:<span class="cov8" title="1">
                return p.parseIsNullExpr(column)</span>
        }

        // Parse standard comparison operator
        <span class="cov8" title="1">operator := p.current().Type
        switch operator </span>{
        case TokenEqual, TokenNotEqual, TokenLess, TokenGreater, TokenLessEqual, TokenGreaterEqual:<span class="cov8" title="1">
                p.advance()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected comparison operator, got %v", operator)</span>
        }

        // Parse right side - could be a literal value or column reference
        <span class="cov8" title="1">switch p.current().Type </span>{
        case TokenString:<span class="cov8" title="1">
                value := p.current().Value
                p.advance()
                return &amp;ComparisonExpr{
                        Column:   column,
                        Operator: operator,
                        Value:    value,
                }, nil</span>
        case TokenNumber:<span class="cov8" title="1">
                numStr := p.current().Value
                // Try to parse as int first, then float
                var value interface{}
                if intVal, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        value = intVal
                }</span> else<span class="cov8" title="1"> if floatVal, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov8" title="1">{
                        value = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid number: %s", numStr)
                }</span>
                <span class="cov8" title="1">p.advance()
                return &amp;ComparisonExpr{
                        Column:   column,
                        Operator: operator,
                        Value:    value,
                }, nil</span>
        case TokenBool:<span class="cov8" title="1">
                value := strings.ToLower(p.current().Value) == "true"
                p.advance()
                return &amp;ComparisonExpr{
                        Column:   column,
                        Operator: operator,
                        Value:    value,
                }, nil</span>
        case TokenIdent:<span class="cov8" title="1">
                // Column-to-column comparison (for JOINs)
                rightColumn := p.current().Value
                p.advance()
                return &amp;ColumnComparisonExpr{
                        LeftColumn:  column,
                        Operator:    operator,
                        RightColumn: rightColumn,
                }, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("expected value (string, number, bool) or column name, got %v", p.current().Type)</span>
        }
}

// parseInExpr parses an IN expression: column IN (val1, val2, ...) or column IN (subquery)
func (p *Parser) parseInExpr(column string) (Expression, error) <span class="cov8" title="1">{
        // Expect IN keyword
        if err := p.expect(TokenIn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect opening parenthesis
        <span class="cov8" title="1">if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after IN: %w", err)
        }</span>

        // Check if it's a subquery (starts with SELECT or WITH)
        <span class="cov8" title="1">if p.current().Type == TokenSelect || p.current().Type == TokenWith </span><span class="cov8" title="1">{
                // Parse subquery
                subquery, err := p.parseQuery()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse IN subquery: %w", err)
                }</span>

                // Validate subquery selects exactly one column
                <span class="cov8" title="1">if len(subquery.SelectList) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("IN subquery must select at least one column")
                }</span>
                // Check for SELECT * which would select multiple columns
                <span class="cov8" title="1">if len(subquery.SelectList) == 1 </span><span class="cov8" title="1">{
                        if colRef, ok := subquery.SelectList[0].Expr.(*ColumnRef); ok &amp;&amp; colRef.Column == "*" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("IN subquery cannot use SELECT *, must select exactly one column")
                        }</span>
                } else<span class="cov0" title="0"> if len(subquery.SelectList) &gt; 1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("IN subquery must select exactly one column, got %d columns", len(subquery.SelectList))
                }</span>

                // Expect closing parenthesis
                <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ')' after IN subquery: %w", err)
                }</span>

                <span class="cov8" title="1">return &amp;InSubqueryExpr{
                        Column:   column,
                        Subquery: subquery,
                        Negate:   false,
                }, nil</span>
        }

        // Parse value list
        <span class="cov8" title="1">var values []interface{}
        for </span><span class="cov8" title="1">{
                var value interface{}
                switch p.current().Type </span>{
                case TokenString:<span class="cov8" title="1">
                        value = p.current().Value
                        p.advance()</span>
                case TokenNumber:<span class="cov8" title="1">
                        numStr := p.current().Value
                        if intVal, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                                value = intVal
                        }</span> else<span class="cov0" title="0"> if floatVal, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                                value = floatVal
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("invalid number in IN list: %s", numStr)
                        }</span>
                        <span class="cov8" title="1">p.advance()</span>
                case TokenBool:<span class="cov0" title="0">
                        value = strings.ToLower(p.current().Value) == "true"
                        p.advance()</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("expected value in IN list, got %v", p.current().Type)</span>
                }
                <span class="cov8" title="1">values = append(values, value)

                // Check for comma (more values) or closing parenthesis
                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }
                <span class="cov8" title="1">if p.current().Type == TokenRightParen </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("expected ',' or ')' in IN list, got %v", p.current().Type)</span>
        }

        // Expect closing parenthesis
        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after IN list: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;InExpr{
                Column: column,
                Values: values,
                Negate: false,
        }, nil</span>
}

// parseLikeExpr parses a LIKE expression: column LIKE 'pattern'
func (p *Parser) parseLikeExpr(column string) (Expression, error) <span class="cov8" title="1">{
        // Expect LIKE keyword
        if err := p.expect(TokenLike); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect string pattern
        <span class="cov8" title="1">if p.current().Type != TokenString </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected string pattern after LIKE, got %v", p.current().Type)
        }</span>
        <span class="cov8" title="1">pattern := p.current().Value
        p.advance()

        return &amp;LikeExpr{
                Column:  column,
                Pattern: pattern,
                Negate:  false,
        }, nil</span>
}

// parseBetweenExpr parses a BETWEEN expression: column BETWEEN lower AND upper
func (p *Parser) parseBetweenExpr(column string) (Expression, error) <span class="cov8" title="1">{
        // Expect BETWEEN keyword
        if err := p.expect(TokenBetween); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse lower bound
        <span class="cov8" title="1">var lower interface{}
        switch p.current().Type </span>{
        case TokenString:<span class="cov8" title="1">
                lower = p.current().Value
                p.advance()</span>
        case TokenNumber:<span class="cov8" title="1">
                numStr := p.current().Value
                if intVal, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        lower = intVal
                }</span> else<span class="cov0" title="0"> if floatVal, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                        lower = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid lower bound: %s", numStr)
                }</span>
                <span class="cov8" title="1">p.advance()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected value for BETWEEN lower bound, got %v", p.current().Type)</span>
        }

        // Expect AND
        <span class="cov8" title="1">if err := p.expect(TokenAnd); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected AND in BETWEEN expression: %w", err)
        }</span>

        // Parse upper bound
        <span class="cov8" title="1">var upper interface{}
        switch p.current().Type </span>{
        case TokenString:<span class="cov8" title="1">
                upper = p.current().Value
                p.advance()</span>
        case TokenNumber:<span class="cov8" title="1">
                numStr := p.current().Value
                if intVal, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        upper = intVal
                }</span> else<span class="cov0" title="0"> if floatVal, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                        upper = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid upper bound: %s", numStr)
                }</span>
                <span class="cov8" title="1">p.advance()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected value for BETWEEN upper bound, got %v", p.current().Type)</span>
        }

        <span class="cov8" title="1">return &amp;BetweenExpr{
                Column: column,
                Lower:  lower,
                Upper:  upper,
                Negate: false,
        }, nil</span>
}

// parseIsNullExpr parses an IS NULL expression: column IS [NOT] NULL
func (p *Parser) parseIsNullExpr(column string) (Expression, error) <span class="cov8" title="1">{
        // Expect IS keyword
        if err := p.expect(TokenIs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check for NOT
        <span class="cov8" title="1">negate := false
        if p.current().Type == TokenNot </span><span class="cov8" title="1">{
                negate = true
                p.advance()
        }</span>

        // Expect NULL
        <span class="cov8" title="1">if err := p.expect(TokenNull); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected NULL after IS [NOT]: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;IsNullExpr{
                Column: column,
                Negate: negate,
        }, nil</span>
}

// parseOrderBy parses the ORDER BY clause
func (p *Parser) parseOrderBy() ([]OrderByItem, error) <span class="cov8" title="1">{
        // Expect ORDER
        if err := p.expect(TokenOrder); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect BY
        <span class="cov8" title="1">if err := p.expect(TokenBy); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected BY after ORDER: %w", err)
        }</span>

        <span class="cov8" title="1">return p.parseOrderByList()</span>
}

// parseOrderByList parses the ORDER BY column list (without ORDER BY keywords)
func (p *Parser) parseOrderByList() ([]OrderByItem, error) <span class="cov8" title="1">{
        var items []OrderByItem

        // Parse column list
        for </span><span class="cov8" title="1">{
                if p.current().Type != TokenIdent </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected column name in ORDER BY, got %v", p.current().Type)
                }</span>

                <span class="cov8" title="1">column := p.current().Value
                if err := ValidateColumnName(column); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">item := OrderByItem{
                        Column: column,
                        Desc:   false, // Default to ASC
                }
                p.advance()

                // Check for ASC/DESC modifier
                if p.current().Type == TokenAsc </span><span class="cov8" title="1">{
                        item.Desc = false
                        p.advance()
                }</span> else<span class="cov8" title="1"> if p.current().Type == TokenDesc </span><span class="cov8" title="1">{
                        item.Desc = true
                        p.advance()
                }</span>

                <span class="cov8" title="1">items = append(items, item)

                // Check for comma (more columns)
                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }

                // No comma, we're done
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ORDER BY requires at least one column")
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

// parseLimit parses the LIMIT clause
func (p *Parser) parseLimit() (*int64, error) <span class="cov8" title="1">{
        // Expect LIMIT
        if err := p.expect(TokenLimit); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect a number
        <span class="cov8" title="1">if p.current().Type != TokenNumber </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected number after LIMIT, got %v", p.current().Type)
        }</span>

        <span class="cov8" title="1">numStr := p.current().Value
        limit, err := strconv.ParseInt(numStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid LIMIT value: %s", numStr)
        }</span>

        <span class="cov8" title="1">if limit &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("LIMIT must be non-negative, got %d", limit)
        }</span>

        <span class="cov8" title="1">p.advance()
        return &amp;limit, nil</span>
}

// parseOffset parses the OFFSET clause
func (p *Parser) parseOffset() (*int64, error) <span class="cov8" title="1">{
        // Expect OFFSET
        if err := p.expect(TokenOffset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect a number
        <span class="cov8" title="1">if p.current().Type != TokenNumber </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected number after OFFSET, got %v", p.current().Type)
        }</span>

        <span class="cov8" title="1">numStr := p.current().Value
        offset, err := strconv.ParseInt(numStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid OFFSET value: %s", numStr)
        }</span>

        <span class="cov8" title="1">if offset &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("OFFSET must be non-negative, got %d", offset)
        }</span>

        <span class="cov8" title="1">p.advance()
        return &amp;offset, nil</span>
}

// parseScalarSubquery parses a scalar subquery in SELECT clause
func (p *Parser) parseScalarSubquery() (SelectExpression, error) <span class="cov8" title="1">{
        // Expect opening parenthesis
        if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' for scalar subquery: %w", err)
        }</span>

        // Parse subquery
        <span class="cov8" title="1">subquery, err := p.parseQuery()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse scalar subquery: %w", err)
        }</span>

        // Validate subquery selects exactly one column
        <span class="cov8" title="1">if len(subquery.SelectList) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scalar subquery must select at least one column")
        }</span>
        // Check for SELECT * which would select multiple columns
        <span class="cov8" title="1">if len(subquery.SelectList) == 1 </span><span class="cov8" title="1">{
                if colRef, ok := subquery.SelectList[0].Expr.(*ColumnRef); ok &amp;&amp; colRef.Column == "*" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scalar subquery cannot use SELECT *, must select exactly one column")
                }</span>
        } else<span class="cov0" title="0"> if len(subquery.SelectList) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scalar subquery must select exactly one column, got %d columns", len(subquery.SelectList))
        }</span>

        // Expect closing parenthesis
        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after scalar subquery: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ScalarSubqueryExpr{
                Query: subquery,
        }, nil</span>
}

// parseExistsExpr parses an EXISTS expression: EXISTS (subquery) or NOT EXISTS (subquery)
func (p *Parser) parseExistsExpr() (Expression, error) <span class="cov8" title="1">{
        negate := false

        // Check for NOT EXISTS
        if p.current().Type == TokenNot </span><span class="cov8" title="1">{
                negate = true
                p.advance()
        }</span>

        // Expect EXISTS keyword
        <span class="cov8" title="1">if err := p.expect(TokenExists); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect opening parenthesis
        <span class="cov8" title="1">if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected '(' after EXISTS: %w", err)
        }</span>

        // Parse subquery
        <span class="cov8" title="1">subquery, err := p.parseQuery()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse EXISTS subquery: %w", err)
        }</span>

        // Expect closing parenthesis
        <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected ')' after EXISTS subquery: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ExistsExpr{
                Subquery: subquery,
                Negate:   negate,
        }, nil</span>
}

// parseWithClause parses the WITH clause (Common Table Expressions)
// Syntax: WITH cte1 AS (query1), cte2 AS (query2)
func (p *Parser) parseWithClause() ([]CTE, error) <span class="cov8" title="1">{
        if err := p.expect(TokenWith); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check for RECURSIVE (not supported yet)
        <span class="cov8" title="1">if p.current().Type == TokenRecursive </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("RECURSIVE CTEs are not supported yet")
        }</span>

        <span class="cov8" title="1">var ctes []CTE

        for </span><span class="cov8" title="1">{
                // Parse CTE name
                if p.current().Type != TokenIdent </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected CTE name, got %v", p.current().Type)
                }</span>
                <span class="cov8" title="1">cteName := p.current().Value
                p.advance()

                // Expect AS
                if err := p.expect(TokenAs); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected AS after CTE name: %w", err)
                }</span>

                // Expect (
                <span class="cov8" title="1">if err := p.expect(TokenLeftParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ( after AS: %w", err)
                }</span>

                // Parse the subquery
                <span class="cov8" title="1">subquery, err := p.parseQuery()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse CTE subquery: %w", err)
                }</span>

                // Expect )
                <span class="cov8" title="1">if err := p.expect(TokenRightParen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("expected ) after CTE subquery: %w", err)
                }</span>

                // Add CTE
                <span class="cov8" title="1">ctes = append(ctes, CTE{
                        Name:  cteName,
                        Query: subquery,
                })

                // Check for comma (more CTEs)
                if p.current().Type == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        continue</span>
                }

                // No comma, we're done with CTEs
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">return ctes, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package query provides SQL query parsing and filtering for parquet data.
//
// It implements a SQL-like query language with support for WHERE clauses,
// comparison operators, and boolean logic (AND/OR). The package includes
// a lexer for tokenization, a parser for building ASTs, and an evaluator
// for filtering data rows.
//
// Example usage:
//
//        query, err := Parse("select * from data.parquet where age &gt; 30")
//        if err != nil {
//            log.Fatal(err)
//        }
//        filtered, err := ApplyFilter(rows, query.Filter)
package query

import "fmt"

// TokenType represents the type of a token
type TokenType int

const (
        // Keywords
        TokenSelect TokenType = iota
        TokenFrom
        TokenWhere
        TokenAnd
        TokenOr
        TokenAs
        TokenGroup
        TokenBy
        TokenHaving
        TokenOrder
        TokenAsc
        TokenDesc
        TokenLimit
        TokenOffset
        TokenIn
        TokenLike
        TokenBetween
        TokenIs
        TokenNot
        TokenNull
        TokenDistinct
        TokenCase
        TokenWhen
        TokenThen
        TokenElse
        TokenEnd
        TokenOver
        TokenPartition
        TokenRows
        TokenRange
        TokenWith
        TokenRecursive
        TokenExists
        TokenJoin
        TokenInner
        TokenLeft
        TokenRight
        TokenFull
        TokenOuter
        TokenCross
        TokenOn

        // Operators
        TokenEqual        // =
        TokenNotEqual     // !=
        TokenLess         // &lt;
        TokenGreater      // &gt;
        TokenLessEqual    // &lt;=
        TokenGreaterEqual // &gt;=

        // Literals
        TokenString
        TokenNumber
        TokenIdent
        TokenBool

        // Delimiters
        TokenComma      // ,
        TokenLeftParen  // (
        TokenRightParen // )

        // Special
        TokenEOF
        TokenError
)

// Token represents a lexical token
type Token struct {
        Type  TokenType
        Value string
}

// Query represents a parsed SQL query
type Query struct {
        CTEs       []CTE  // WITH clause CTEs
        TableName  string // Single file path or glob pattern
        Subquery   *Query // Subquery in FROM clause (alternative to TableName)
        TableAlias string // Optional alias for table/subquery
        Joins      []Join // JOIN clauses
        SelectList []SelectItem
        Filter     Expression
        GroupBy    []string      // Column names to group by
        Having     Expression    // Post-aggregation filter
        OrderBy    []OrderByItem // Sort specification
        Limit      *int64        // Row limit
        Offset     *int64        // Row offset
        Distinct   bool          // DISTINCT modifier
}

// JoinType represents the type of join operation
type JoinType int

const (
        JoinInner JoinType = iota // INNER JOIN (default)
        JoinLeft                  // LEFT JOIN / LEFT OUTER JOIN
        JoinRight                 // RIGHT JOIN / RIGHT OUTER JOIN
        JoinFull                  // FULL JOIN / FULL OUTER JOIN
        JoinCross                 // CROSS JOIN
)

// Join represents a JOIN clause
type Join struct {
        Type      JoinType   // Type of join (INNER, LEFT, RIGHT, FULL, CROSS)
        TableName string     // Table/file to join
        Subquery  *Query     // Subquery to join (alternative to TableName)
        Alias     string     // Optional alias for joined table/subquery
        Condition Expression // ON clause condition (nil for CROSS JOIN)
}

// CTE represents a Common Table Expression (WITH clause)
type CTE struct {
        Name  string // CTE name
        Query *Query // Subquery defining the CTE
}

// OrderByItem represents a column to sort by
type OrderByItem struct {
        Column string // Column name or alias
        Desc   bool   // DESC vs ASC (default)
}

// SelectItem represents a column or expression in the SELECT list
type SelectItem struct {
        Expr  SelectExpression // Column, function, or expression
        Alias string           // Optional alias (AS name)
}

// SelectExpression is an expression that can appear in a SELECT list
type SelectExpression interface {
        EvaluateSelect(row map[string]interface{}) (interface{}, error)
}

// ColumnRef references a column (or * for all columns)
type ColumnRef struct {
        Column string // Column name or "*"
}

// FunctionCall represents a function invocation
type FunctionCall struct {
        Name string
        Args []SelectExpression
}

// LiteralExpr represents a literal value (number, string, bool)
type LiteralExpr struct {
        Value interface{}
}

// AggregateExpr represents an aggregate function (COUNT, SUM, AVG, MIN, MAX)
type AggregateExpr struct {
        Function string           // COUNT, SUM, AVG, MIN, MAX
        Arg      SelectExpression // Argument expression (nil for COUNT(*))
        Distinct bool             // DISTINCT modifier (not implemented yet)
}

// CaseExpr represents a CASE expression
type CaseExpr struct {
        WhenClauses []WhenClause     // WHEN conditions and their results
        ElseExpr    SelectExpression // ELSE result (optional)
}

// WhenClause represents a single WHEN condition and result
type WhenClause struct {
        Condition Expression       // WHEN condition
        Result    SelectExpression // THEN result
}

// WindowExpr represents a window function call
type WindowExpr struct {
        Function string             // Window function name (ROW_NUMBER, RANK, etc.)
        Args     []SelectExpression // Function arguments
        Window   *WindowSpec        // Window specification
}

// WindowSpec specifies the window behavior
type WindowSpec struct {
        PartitionBy []string      // PARTITION BY column names
        OrderBy     []OrderByItem // ORDER BY specification
        Frame       *WindowFrame  // Frame specification (ROWS/RANGE)
}

// WindowFrame specifies the window frame
type WindowFrame struct {
        Type  FrameType  // ROWS or RANGE
        Start FrameBound // Frame start
        End   FrameBound // Frame end
}

// FrameType represents the type of window frame
type FrameType int

const (
        FrameTypeRows FrameType = iota
        FrameTypeRange
)

// FrameBound represents a frame boundary
type FrameBound struct {
        Type   BoundType // UNBOUNDED, CURRENT, OFFSET
        Offset int64     // Offset for OFFSET bound type
}

// BoundType represents the type of frame bound
type BoundType int

const (
        BoundUnboundedPreceding BoundType = iota
        BoundOffsetPreceding
        BoundCurrentRow
        BoundOffsetFollowing
        BoundUnboundedFollowing
)

// Expression represents a boolean expression in the WHERE clause
type Expression interface {
        Evaluate(row map[string]interface{}) (bool, error)
}

// BinaryExpr represents a binary expression (AND/OR)
type BinaryExpr struct {
        Left     Expression
        Operator TokenType // TokenAnd or TokenOr
        Right    Expression
}

// ComparisonExpr represents a comparison expression (column op literal)
type ComparisonExpr struct {
        Column   string
        Operator TokenType
        Value    interface{}
}

// ColumnComparisonExpr represents a column-to-column comparison (col1 op col2)
type ColumnComparisonExpr struct {
        LeftColumn  string
        Operator    TokenType
        RightColumn string
}

// InExpr represents an IN expression (col IN (val1, val2, ...))
type InExpr struct {
        Column string
        Values []interface{}
        Negate bool // NOT IN
}

// LikeExpr represents a LIKE expression (col LIKE 'pattern')
type LikeExpr struct {
        Column  string
        Pattern string
        Negate  bool // NOT LIKE
}

// BetweenExpr represents a BETWEEN expression (col BETWEEN lower AND upper)
type BetweenExpr struct {
        Column string
        Lower  interface{}
        Upper  interface{}
        Negate bool // NOT BETWEEN
}

// IsNullExpr represents an IS NULL expression (col IS NULL / col IS NOT NULL)
type IsNullExpr struct {
        Column string
        Negate bool // IS NOT NULL
}

// SubqueryExpr represents a subquery in WHERE clause (for IN, EXISTS, or scalar)
type SubqueryExpr struct {
        Query *Query
        Type  SubqueryType // IN, EXISTS, SCALAR
}

// ExistsExpr represents an EXISTS expression
type ExistsExpr struct {
        Subquery *Query
        Negate   bool // NOT EXISTS
}

// InSubqueryExpr represents an IN expression with a subquery
type InSubqueryExpr struct {
        Column   string
        Subquery *Query
        Negate   bool // NOT IN
}

// SubqueryType represents the type of subquery
type SubqueryType int

const (
        SubqueryScalar SubqueryType = iota // Returns single value
        SubqueryIn                         // Used in IN clause
        SubqueryExists                     // Used in EXISTS clause
)

// ScalarSubqueryExpr represents a scalar subquery in SELECT or WHERE
type ScalarSubqueryExpr struct {
        Query *Query
}

// Evaluate evaluates a binary expression
func (b *BinaryExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        left, err := b.Left.Evaluate(row)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">right, err := b.Right.Evaluate(row)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">switch b.Operator </span>{
        case TokenAnd:<span class="cov8" title="1">
                return left &amp;&amp; right, nil</span>
        case TokenOr:<span class="cov8" title="1">
                return left || right, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported binary operator: %v", b.Operator)</span>
        }
}

// Evaluate evaluates a comparison expression
func (c *ComparisonExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        value, exists := row[c.Column]
        if !exists </span><span class="cov8" title="1">{
                return false, fmt.Errorf("column %q not found", c.Column)
        }</span>

        <span class="cov8" title="1">return compare(value, c.Operator, c.Value)</span>
}

// Evaluate evaluates a column-to-column comparison expression
func (c *ColumnComparisonExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        leftValue, leftExists := row[c.LeftColumn]
        rightValue, rightExists := row[c.RightColumn]

        // If either column doesn't exist, comparison fails
        if !leftExists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("column %q not found", c.LeftColumn)
        }</span>
        <span class="cov8" title="1">if !rightExists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("column %q not found", c.RightColumn)
        }</span>

        <span class="cov8" title="1">return compare(leftValue, c.Operator, rightValue)</span>
}

// Evaluate evaluates an IN expression
func (i *InExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        value, exists := row[i.Column]
        if !exists </span><span class="cov8" title="1">{
                return false, fmt.Errorf("column %q not found", i.Column)
        }</span>

        // Check if value is in the list
        <span class="cov8" title="1">found := false
        for _, listValue := range i.Values </span><span class="cov8" title="1">{
                match, err := compare(value, TokenEqual, listValue)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }

        // Apply negation if needed
        <span class="cov8" title="1">if i.Negate </span><span class="cov8" title="1">{
                return !found, nil
        }</span>
        <span class="cov8" title="1">return found, nil</span>
}

// Evaluate evaluates a LIKE expression
func (l *LikeExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        value, exists := row[l.Column]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("column %q not found", l.Column)
        }</span>

        // Convert value to string
        <span class="cov8" title="1">str, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("LIKE requires string column, got %T", value)
        }</span>

        // Match the LIKE pattern
        <span class="cov8" title="1">match := matchLikePattern(str, l.Pattern)

        // Apply negation if needed
        if l.Negate </span><span class="cov8" title="1">{
                return !match, nil
        }</span>
        <span class="cov8" title="1">return match, nil</span>
}

// Evaluate evaluates a BETWEEN expression
func (b *BetweenExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        value, exists := row[b.Column]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("column %q not found", b.Column)
        }</span>

        // Check if value &gt;= lower
        <span class="cov8" title="1">lowerMatch, err := compare(value, TokenGreaterEqual, b.Lower)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check if value &lt;= upper
        <span class="cov8" title="1">upperMatch, err := compare(value, TokenLessEqual, b.Upper)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Value is between if it satisfies both conditions
        <span class="cov8" title="1">between := lowerMatch &amp;&amp; upperMatch

        // Apply negation if needed
        if b.Negate </span><span class="cov8" title="1">{
                return !between, nil
        }</span>
        <span class="cov8" title="1">return between, nil</span>
}

// Evaluate evaluates an IS NULL expression
func (i *IsNullExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        value, exists := row[i.Column]

        // Check if the column exists and is nil
        isNull := !exists || value == nil

        // Apply negation if needed (IS NOT NULL)
        if i.Negate </span><span class="cov8" title="1">{
                return !isNull, nil
        }</span>
        <span class="cov8" title="1">return isNull, nil</span>
}

// EvaluateSelect evaluates a column reference
func (c *ColumnRef) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Special case: * means all columns
        if c.Column == "*" </span><span class="cov8" title="1">{
                return row, nil
        }</span>

        <span class="cov8" title="1">value, exists := row[c.Column]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("column %q not found", c.Column)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// EvaluateSelect evaluates a function call
func (f *FunctionCall) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Look up the function in the registry
        registry := GetGlobalRegistry()
        fn, exists := registry.Get(f.Name)
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown function: %s", f.Name)
        }</span>

        // Evaluate all arguments
        <span class="cov8" title="1">args := make([]interface{}, len(f.Args))
        for i, arg := range f.Args </span><span class="cov8" title="1">{
                val, err := arg.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("function %s: argument %d: %w", f.Name, i+1, err)
                }</span>
                <span class="cov8" title="1">args[i] = val</span>
        }

        // Check arity
        <span class="cov8" title="1">minArity := fn.MinArity()
        maxArity := fn.MaxArity()
        argCount := len(args)

        if minArity &gt;= 0 &amp;&amp; argCount &lt; minArity </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("function %s: expected at least %d arguments, got %d", f.Name, minArity, argCount)
        }</span>
        <span class="cov8" title="1">if maxArity &gt;= 0 &amp;&amp; argCount &gt; maxArity </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("function %s: expected at most %d arguments, got %d", f.Name, maxArity, argCount)
        }</span>

        // Call the function
        <span class="cov8" title="1">return fn.Evaluate(args)</span>
}

// EvaluateSelect evaluates a literal expression
func (l *LiteralExpr) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        return l.Value, nil
}</span>

// EvaluateSelect for AggregateExpr is handled separately in the aggregation logic
// This method should not be called directly on raw rows
func (a *AggregateExpr) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("aggregate function %s cannot be evaluated on individual rows", a.Function)
}</span>

// EvaluateSelect evaluates a CASE expression
func (c *CaseExpr) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // Evaluate each WHEN clause in order
        for _, whenClause := range c.WhenClauses </span><span class="cov8" title="1">{
                // Evaluate the condition
                conditionResult, err := whenClause.Condition.Evaluate(row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("CASE: evaluating WHEN condition: %w", err)
                }</span>

                // If condition is true, return the result
                <span class="cov8" title="1">if conditionResult </span><span class="cov8" title="1">{
                        result, err := whenClause.Result.EvaluateSelect(row)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("CASE: evaluating THEN result: %w", err)
                        }</span>
                        <span class="cov8" title="1">return result, nil</span>
                }
        }

        // If no WHEN clause matched, evaluate ELSE (or return nil if no ELSE)
        <span class="cov8" title="1">if c.ElseExpr != nil </span><span class="cov8" title="1">{
                result, err := c.ElseExpr.EvaluateSelect(row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("CASE: evaluating ELSE result: %w", err)
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

// EvaluateSelect for WindowExpr is handled separately in the window execution logic
// This method should not be called directly on raw rows
func (w *WindowExpr) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("window function %s cannot be evaluated on individual rows", w.Function)
}</span>

// Evaluate evaluates an EXISTS expression
// Note: This requires access to subquery execution context, which is handled in the executor
func (e *ExistsExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        return false, fmt.Errorf("EXISTS subquery evaluation requires executor context")
}</span>

// Evaluate evaluates an IN subquery expression
// Note: This requires access to subquery execution context, which is handled in the executor
func (i *InSubqueryExpr) Evaluate(row map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        return false, fmt.Errorf("IN subquery evaluation requires executor context")
}</span>

// EvaluateSelect evaluates a scalar subquery
// Note: This requires access to subquery execution context, which is handled in the executor
func (s *ScalarSubqueryExpr) EvaluateSelect(row map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("scalar subquery evaluation requires executor context")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package query

import (
        "errors"
        "fmt"
)

// Validation constants to prevent DoS and resource exhaustion
const (
        // MaxQueryLength is the maximum allowed query string length (1MB)
        MaxQueryLength = 1024 * 1024

        // MaxTokens is the maximum number of tokens in a query
        MaxTokens = 1000

        // MaxExpressionDepth is the maximum nesting depth for expressions
        MaxExpressionDepth = 100

        // MaxColumnNameLength is the maximum length for a column name
        MaxColumnNameLength = 256

        // MaxTableNameLength is the maximum length for a table name
        MaxTableNameLength = 4096 // Allow long file paths
)

var (
        // ErrQueryTooLong is returned when query exceeds MaxQueryLength
        ErrQueryTooLong = errors.New("query too long")

        // ErrTooManyTokens is returned when query has too many tokens
        ErrTooManyTokens = errors.New("too many tokens in query")

        // ErrExpressionTooDeep is returned when expression nesting exceeds limit
        ErrExpressionTooDeep = errors.New("expression nesting too deep")

        // ErrColumnNameTooLong is returned when column name is too long
        ErrColumnNameTooLong = errors.New("column name too long")

        // ErrTableNameTooLong is returned when table name is too long
        ErrTableNameTooLong = errors.New("table name too long")

        // ErrEmptyTableName is returned when table name is empty
        ErrEmptyTableName = errors.New("table name cannot be empty")
)

// ValidateQuery performs security validation on query input
func ValidateQuery(query string) error <span class="cov8" title="1">{
        if len(query) &gt; MaxQueryLength </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d bytes (max %d)", ErrQueryTooLong, len(query), MaxQueryLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTableName validates table name length and content
func ValidateTableName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return ErrEmptyTableName
        }</span>
        <span class="cov8" title="1">if len(name) &gt; MaxTableNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d chars (max %d)", ErrTableNameTooLong, len(name), MaxTableNameLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateColumnName validates column name length
func ValidateColumnName(name string) error <span class="cov8" title="1">{
        if len(name) &gt; MaxColumnNameLength </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d chars (max %d)", ErrColumnNameTooLong, len(name), MaxColumnNameLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTokens validates token count
func ValidateTokens(tokens []Token) error <span class="cov8" title="1">{
        if len(tokens) &gt; MaxTokens </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d tokens (max %d)", ErrTooManyTokens, len(tokens), MaxTokens)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ExpressionDepthCounter tracks expression nesting depth
type ExpressionDepthCounter struct {
        depth    int
        maxDepth int
}

// NewExpressionDepthCounter creates a new depth counter
func NewExpressionDepthCounter() *ExpressionDepthCounter <span class="cov8" title="1">{
        return &amp;ExpressionDepthCounter{depth: 0, maxDepth: MaxExpressionDepth}
}</span>

// Enter increments depth and returns error if limit exceeded
func (c *ExpressionDepthCounter) Enter() error <span class="cov8" title="1">{
        c.depth++
        if c.depth &gt; c.maxDepth </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d (max %d)", ErrExpressionTooDeep, c.depth, c.maxDepth)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Exit decrements depth
func (c *ExpressionDepthCounter) Exit() <span class="cov8" title="1">{
        c.depth--
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package query

import (
        "fmt"
        "sort"
        "strings"
)

// HasWindowFunction checks if the SELECT list contains any window functions
func HasWindowFunction(selectList []SelectItem) bool <span class="cov8" title="1">{
        for _, item := range selectList </span><span class="cov8" title="1">{
                if _, ok := item.Expr.(*WindowExpr); ok </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// HasSubqueryInWHERE checks if the WHERE clause contains any subqueries
func HasSubqueryInWHERE(filter Expression) bool <span class="cov8" title="1">{
        if filter == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return hasSubqueryInExpression(filter)</span>
}

// hasSubqueryInExpression recursively checks if an expression contains subqueries
func hasSubqueryInExpression(expr Expression) bool <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch e := expr.(type) </span>{
        case *InSubqueryExpr:<span class="cov8" title="1">
                return true</span>
        case *ExistsExpr:<span class="cov8" title="1">
                return true</span>
        case *BinaryExpr:<span class="cov8" title="1">
                return hasSubqueryInExpression(e.Left) || hasSubqueryInExpression(e.Right)</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// HasSubqueryInSELECT checks if the SELECT list contains any scalar subqueries
func HasSubqueryInSELECT(selectList []SelectItem) bool <span class="cov8" title="1">{
        for _, item := range selectList </span><span class="cov8" title="1">{
                if hasScalarSubquery(item.Expr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// hasScalarSubquery recursively checks if a SelectExpression contains scalar subqueries
func hasScalarSubquery(expr SelectExpression) bool <span class="cov8" title="1">{
        if expr == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch e := expr.(type) </span>{
        case *ScalarSubqueryExpr:<span class="cov8" title="1">
                return true</span>
        case *FunctionCall:<span class="cov8" title="1">
                // Check function arguments
                for _, arg := range e.Args </span><span class="cov8" title="1">{
                        if hasScalarSubquery(arg) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        case *CaseExpr:<span class="cov8" title="1">
                // Check ELSE expression
                if e.ElseExpr != nil &amp;&amp; hasScalarSubquery(e.ElseExpr) </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Check each WHEN result
                <span class="cov8" title="1">for _, when := range e.WhenClauses </span><span class="cov8" title="1">{
                        if hasScalarSubquery(when.Result) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// ApplyWindowFunctions processes window functions in the SELECT list
// This must be called AFTER WHERE filtering but BEFORE regular column projection
func ApplyWindowFunctions(rows []map[string]interface{}, selectList []SelectItem) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        // Check if there are any window functions
        hasWindowFunc := false
        for _, item := range selectList </span><span class="cov8" title="1">{
                if _, ok := item.Expr.(*WindowExpr); ok </span><span class="cov8" title="1">{
                        hasWindowFunc = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !hasWindowFunc </span><span class="cov0" title="0">{
                return rows, nil
        }</span>

        // Create a result set with window function results added as new columns
        <span class="cov8" title="1">result := make([]map[string]interface{}, len(rows))
        for i := range rows </span><span class="cov8" title="1">{
                // Copy the original row
                result[i] = make(map[string]interface{})
                for k, v := range rows[i] </span><span class="cov8" title="1">{
                        result[i][k] = v
                }</span>
        }

        // Process each window function
        <span class="cov8" title="1">for _, item := range selectList </span><span class="cov8" title="1">{
                windowExpr, ok := item.Expr.(*WindowExpr)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Compute window function results
                <span class="cov8" title="1">values, err := computeWindowFunction(rows, windowExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to compute window function %s: %w", windowExpr.Function, err)
                }</span>

                // Determine the column name to use
                <span class="cov8" title="1">columnName := item.Alias
                if columnName == "" </span><span class="cov0" title="0">{
                        columnName = windowExpr.Function
                }</span>

                // Add the results to each row
                <span class="cov8" title="1">for i, value := range values </span><span class="cov8" title="1">{
                        result[i][columnName] = value
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// computeWindowFunction computes the result of a window function for all rows
func computeWindowFunction(rows []map[string]interface{}, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(rows) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">spec := windowExpr.Window
        if spec == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("window function %s requires OVER clause", windowExpr.Function)
        }</span>

        // Create partitions based on PARTITION BY
        <span class="cov8" title="1">partitions := partitionRows(rows, spec.PartitionBy)

        // For each partition, sort by ORDER BY and compute window function
        results := make([]interface{}, len(rows))

        for _, partition := range partitions </span><span class="cov8" title="1">{
                // Sort partition by ORDER BY
                sortedPartition := sortPartition(partition, spec.OrderBy)

                // Compute window function for this partition
                partitionResults, err := computeWindowFunctionForPartition(sortedPartition, windowExpr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Map results back to original row indices
                <span class="cov8" title="1">for i, rowInfo := range sortedPartition </span><span class="cov8" title="1">{
                        results[rowInfo.originalIndex] = partitionResults[i]
                }</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// rowInfo stores a row with its original index
type rowInfo struct {
        row           map[string]interface{}
        originalIndex int
}

// partitionRows partitions rows based on PARTITION BY columns
func partitionRows(rows []map[string]interface{}, partitionBy []string) [][]rowInfo <span class="cov8" title="1">{
        if len(partitionBy) == 0 </span><span class="cov8" title="1">{
                // No PARTITION BY: all rows are in one partition
                partition := make([]rowInfo, len(rows))
                for i, row := range rows </span><span class="cov8" title="1">{
                        partition[i] = rowInfo{row: row, originalIndex: i}
                }</span>
                <span class="cov8" title="1">return [][]rowInfo{partition}</span>
        }

        // Create partitions based on partition key
        <span class="cov8" title="1">partitionMap := make(map[string][]rowInfo)

        for i, row := range rows </span><span class="cov8" title="1">{
                key := makePartitionKey(row, partitionBy)
                partitionMap[key] = append(partitionMap[key], rowInfo{row: row, originalIndex: i})
        }</span>

        // Convert map to slice
        <span class="cov8" title="1">partitions := make([][]rowInfo, 0, len(partitionMap))
        for _, partition := range partitionMap </span><span class="cov8" title="1">{
                partitions = append(partitions, partition)
        }</span>

        <span class="cov8" title="1">return partitions</span>
}

// makePartitionKey creates a partition key from a row
func makePartitionKey(row map[string]interface{}, columns []string) string <span class="cov8" title="1">{
        var keyBuilder strings.Builder
        for i, col := range columns </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        keyBuilder.WriteString("\x00||\x00") // Use unlikely separator to avoid collisions
                }</span>
                // Include column name in key to prevent cross-column collisions
                <span class="cov8" title="1">keyBuilder.WriteString(col)
                keyBuilder.WriteString("\x00:\x00")
                keyBuilder.WriteString(fmt.Sprintf("%#v", row[col]))</span> // Use %#v for better type differentiation
        }
        <span class="cov8" title="1">return keyBuilder.String()</span>
}

// sortPartition sorts a partition by ORDER BY columns
func sortPartition(partition []rowInfo, orderBy []OrderByItem) []rowInfo <span class="cov8" title="1">{
        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                return partition
        }</span>

        <span class="cov8" title="1">sorted := make([]rowInfo, len(partition))
        copy(sorted, partition)

        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                for _, item := range orderBy </span><span class="cov8" title="1">{
                        valI := sorted[i].row[item.Column]
                        valJ := sorted[j].row[item.Column]

                        cmp := compareValues(valI, valJ)
                        if cmp != 0 </span><span class="cov8" title="1">{
                                if item.Desc </span><span class="cov8" title="1">{
                                        return cmp &gt; 0
                                }</span>
                                <span class="cov8" title="1">return cmp &lt; 0</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return sorted</span>
}

// computeWindowFunctionForPartition computes a window function for a sorted partition
func computeWindowFunctionForPartition(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        function := windowExpr.Function

        switch function </span>{
        case "ROW_NUMBER":<span class="cov8" title="1">
                return computeRowNumber(partition, windowExpr)</span>
        case "RANK":<span class="cov8" title="1">
                return computeRank(partition, windowExpr)</span>
        case "DENSE_RANK":<span class="cov8" title="1">
                return computeDenseRank(partition, windowExpr)</span>
        case "NTILE":<span class="cov8" title="1">
                return computeNTile(partition, windowExpr)</span>
        case "FIRST_VALUE":<span class="cov8" title="1">
                return computeFirstValue(partition, windowExpr)</span>
        case "LAST_VALUE":<span class="cov8" title="1">
                return computeLastValue(partition, windowExpr)</span>
        case "NTH_VALUE":<span class="cov8" title="1">
                return computeNthValue(partition, windowExpr)</span>
        case "LAG":<span class="cov8" title="1">
                return computeLag(partition, windowExpr)</span>
        case "LEAD":<span class="cov8" title="1">
                return computeLead(partition, windowExpr)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported window function: %s", function)</span>
        }
}

// computeRowNumber computes ROW_NUMBER() for a partition
func computeRowNumber(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        results := make([]interface{}, len(partition))
        for i := range partition </span><span class="cov8" title="1">{
                results[i] = int64(i + 1)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

// computeRank computes RANK() for a partition
func computeRank(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">spec := windowExpr.Window
        orderBy := spec.OrderBy

        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                // Without ORDER BY, all rows have the same rank
                results := make([]interface{}, len(partition))
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = int64(1)
                }</span>
                <span class="cov0" title="0">return results, nil</span>
        }

        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        rank := int64(1)

        for i := 0; i &lt; len(partition); i++ </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; !rowsEqualOnOrderBy(partition[i-1].row, partition[i].row, orderBy) </span><span class="cov8" title="1">{
                        rank = int64(i + 1)
                }</span>
                <span class="cov8" title="1">results[i] = rank</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// computeDenseRank computes DENSE_RANK() for a partition
func computeDenseRank(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">spec := windowExpr.Window
        orderBy := spec.OrderBy

        if len(orderBy) == 0 </span><span class="cov0" title="0">{
                // Without ORDER BY, all rows have the same rank
                results := make([]interface{}, len(partition))
                for i := range results </span><span class="cov0" title="0">{
                        results[i] = int64(1)
                }</span>
                <span class="cov0" title="0">return results, nil</span>
        }

        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        rank := int64(1)

        for i := 0; i &lt; len(partition); i++ </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; !rowsEqualOnOrderBy(partition[i-1].row, partition[i].row, orderBy) </span><span class="cov8" title="1">{
                        rank++
                }</span>
                <span class="cov8" title="1">results[i] = rank</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// computeNTile computes NTILE(n) for a partition
func computeNTile(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTILE requires exactly one argument")
        }</span>

        // Evaluate the argument to get the number of tiles
        <span class="cov8" title="1">nArg, err := windowExpr.Args[0].EvaluateSelect(partition[0].row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTILE: failed to evaluate argument: %w", err)
        }</span>

        <span class="cov8" title="1">nFloat, ok := toFloat64(nArg)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTILE: argument must be a number")
        }</span>
        <span class="cov8" title="1">n := int64(nFloat)

        if n &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTILE: argument must be positive")
        }</span>

        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        rowCount := int64(len(partition))

        // SQL standard allows NTILE(n) where n &gt; rowCount
        // In this case, each row gets its own tile number (1, 2, 3, ...)
        // and tiles beyond rowCount are empty
        if n &gt; rowCount </span><span class="cov0" title="0">{
                // Each row gets its own tile number
                for i := int64(0); i &lt; rowCount; i++ </span><span class="cov0" title="0">{
                        results[i] = i + 1
                }</span>
                <span class="cov0" title="0">return results, nil</span>
        }

        // Calculate tile size
        <span class="cov8" title="1">tileSize := rowCount / n
        remainder := rowCount % n

        tile := int64(1)
        rowsInCurrentTile := int64(0)
        currentTileSize := tileSize
        if remainder &gt; 0 </span><span class="cov0" title="0">{
                currentTileSize++
        }</span>

        <span class="cov8" title="1">for i := int64(0); i &lt; rowCount; i++ </span><span class="cov8" title="1">{
                if rowsInCurrentTile &gt;= currentTileSize </span><span class="cov8" title="1">{
                        tile++
                        rowsInCurrentTile = 0
                        if tile-1 &lt; remainder </span><span class="cov0" title="0">{
                                currentTileSize = tileSize + 1
                        }</span> else<span class="cov8" title="1"> {
                                currentTileSize = tileSize
                        }</span>
                }
                <span class="cov8" title="1">results[i] = tile
                rowsInCurrentTile++</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// computeFirstValue computes FIRST_VALUE(expr) for a partition
func computeFirstValue(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FIRST_VALUE requires exactly one argument")
        }</span>

        // Evaluate the expression on the first row
        <span class="cov8" title="1">firstValue, err := windowExpr.Args[0].EvaluateSelect(partition[0].row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("FIRST_VALUE: failed to evaluate argument: %w", err)
        }</span>

        // Return the first value for all rows
        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        for i := range results </span><span class="cov8" title="1">{
                results[i] = firstValue
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// computeLastValue computes LAST_VALUE(expr) for a partition
func computeLastValue(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LAST_VALUE requires exactly one argument")
        }</span>

        // Evaluate the expression on the last row
        <span class="cov8" title="1">lastValue, err := windowExpr.Args[0].EvaluateSelect(partition[len(partition)-1].row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LAST_VALUE: failed to evaluate argument: %w", err)
        }</span>

        // Return the last value for all rows
        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        for i := range results </span><span class="cov8" title="1">{
                results[i] = lastValue
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// computeNthValue computes NTH_VALUE(expr, n) for a partition
func computeNthValue(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTH_VALUE requires exactly two arguments")
        }</span>

        // Evaluate the n argument
        <span class="cov8" title="1">nArg, err := windowExpr.Args[1].EvaluateSelect(partition[0].row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTH_VALUE: failed to evaluate position argument: %w", err)
        }</span>

        <span class="cov8" title="1">nFloat, ok := toFloat64(nArg)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTH_VALUE: position argument must be a number")
        }</span>
        <span class="cov8" title="1">n := int(nFloat)

        if n &lt;= 0 || n &gt; len(partition) </span><span class="cov0" title="0">{
                // Return NULL for all rows if n is out of range
                results := make([]interface{}, len(partition))
                return results, nil
        }</span>

        // Evaluate the expression on the nth row (1-indexed)
        <span class="cov8" title="1">nthValue, err := windowExpr.Args[0].EvaluateSelect(partition[n-1].row)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NTH_VALUE: failed to evaluate argument: %w", err)
        }</span>

        // Return the nth value for all rows
        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        for i := range results </span><span class="cov8" title="1">{
                results[i] = nthValue
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// computeLag computes LAG(expr, offset, default) for a partition
func computeLag(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) &lt; 1 || len(windowExpr.Args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LAG requires 1-3 arguments")
        }</span>

        // Get offset (default 1)
        <span class="cov8" title="1">offset := int64(1)
        if len(windowExpr.Args) &gt;= 2 </span><span class="cov8" title="1">{
                offsetArg, err := windowExpr.Args[1].EvaluateSelect(partition[0].row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LAG: failed to evaluate offset argument: %w", err)
                }</span>
                <span class="cov8" title="1">offsetFloat, ok := toFloat64(offsetArg)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LAG: offset argument must be a number")
                }</span>
                <span class="cov8" title="1">offset = int64(offsetFloat)
                if offset &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LAG: offset must be non-negative, got %d", offset)
                }</span>
        }

        // Get default value (default NULL)
        <span class="cov8" title="1">var defaultValue interface{} = nil
        if len(windowExpr.Args) == 3 </span><span class="cov0" title="0">{
                var err error
                defaultValue, err = windowExpr.Args[2].EvaluateSelect(partition[0].row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LAG: failed to evaluate default argument: %w", err)
                }</span>
        }

        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        for i := range partition </span><span class="cov8" title="1">{
                lagIndex := int64(i) - offset
                if lagIndex &lt; 0 </span><span class="cov8" title="1">{
                        results[i] = defaultValue
                }</span> else<span class="cov8" title="1"> {
                        value, err := windowExpr.Args[0].EvaluateSelect(partition[lagIndex].row)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("LAG: failed to evaluate expression: %w", err)
                        }</span>
                        <span class="cov8" title="1">results[i] = value</span>
                }
        }

        <span class="cov8" title="1">return results, nil</span>
}

// computeLead computes LEAD(expr, offset, default) for a partition
func computeLead(partition []rowInfo, windowExpr *WindowExpr) ([]interface{}, error) <span class="cov8" title="1">{
        if len(partition) == 0 </span><span class="cov0" title="0">{
                return []interface{}{}, nil
        }</span>

        <span class="cov8" title="1">if len(windowExpr.Args) &lt; 1 || len(windowExpr.Args) &gt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LEAD requires 1-3 arguments")
        }</span>

        // Get offset (default 1)
        <span class="cov8" title="1">offset := int64(1)
        if len(windowExpr.Args) &gt;= 2 </span><span class="cov8" title="1">{
                offsetArg, err := windowExpr.Args[1].EvaluateSelect(partition[0].row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LEAD: failed to evaluate offset argument: %w", err)
                }</span>
                <span class="cov8" title="1">offsetFloat, ok := toFloat64(offsetArg)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LEAD: offset argument must be a number")
                }</span>
                <span class="cov8" title="1">offset = int64(offsetFloat)
                if offset &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LEAD: offset must be non-negative, got %d", offset)
                }</span>
        }

        // Get default value (default NULL)
        <span class="cov8" title="1">var defaultValue interface{} = nil
        if len(windowExpr.Args) == 3 </span><span class="cov0" title="0">{
                var err error
                defaultValue, err = windowExpr.Args[2].EvaluateSelect(partition[0].row)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LEAD: failed to evaluate default argument: %w", err)
                }</span>
        }

        <span class="cov8" title="1">results := make([]interface{}, len(partition))
        for i := range partition </span><span class="cov8" title="1">{
                leadIndex := int64(i) + offset
                if leadIndex &gt;= int64(len(partition)) </span><span class="cov8" title="1">{
                        results[i] = defaultValue
                }</span> else<span class="cov8" title="1"> {
                        value, err := windowExpr.Args[0].EvaluateSelect(partition[leadIndex].row)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("LEAD: failed to evaluate expression: %w", err)
                        }</span>
                        <span class="cov8" title="1">results[i] = value</span>
                }
        }

        <span class="cov8" title="1">return results, nil</span>
}

// rowsEqualOnOrderBy checks if two rows are equal on all ORDER BY columns
func rowsEqualOnOrderBy(row1, row2 map[string]interface{}, orderBy []OrderByItem) bool <span class="cov8" title="1">{
        for _, item := range orderBy </span><span class="cov8" title="1">{
                val1 := row1[item.Column]
                val2 := row2[item.Column]

                if compareValues(val1, val2) != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package reader provides functionality for reading Apache Parquet files.
//
// It uses the segmentio/parquet-go library to read parquet files and returns
// rows as maps for flexible data access.
package reader

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/parquet-go/parquet-go"
)

// Reader reads parquet files and returns rows as maps.
//
// It maintains both an OS file handle and a parquet file handle to enable
// proper resource cleanup.
type Reader struct {
        file   *os.File
        pqFile *parquet.File
}

// NewReader creates a new parquet reader for the specified file path.
//
// The file is opened and validated as a parquet file. Returns an error if
// the file doesn't exist or is not a valid parquet file.
//
// Example:
//
//        reader, err := NewReader("data.parquet")
//        if err != nil {
//            log.Fatal(err)
//        }
//        defer reader.Close()
func NewReader(path string) (*Reader, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>

        <span class="cov8" title="1">stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                _ = file.Close()
                return nil, fmt.Errorf("failed to stat file: %w", err)
        }</span>

        <span class="cov8" title="1">pqFile, err := parquet.OpenFile(file, stat.Size())
        if err != nil </span><span class="cov8" title="1">{
                _ = file.Close()
                return nil, fmt.Errorf("failed to open parquet file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Reader{
                file:   file,
                pqFile: pqFile,
        }, nil</span>
}

// ReadAll reads all rows from the parquet file into memory.
//
// Each row is returned as a map where keys are column names and values are
// the column values. The entire file is loaded into memory, so this method
// may not be suitable for very large files.
//
// Returns an error if any row fails to read.
func (r *Reader) ReadAll() ([]map[string]interface{}, error) <span class="cov8" title="1">{
        rows := make([]map[string]interface{}, 0)

        reader := parquet.NewReader(r.pqFile)
        defer func() </span><span class="cov8" title="1">{ _ = reader.Close() }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                row := make(map[string]interface{})
                err := reader.Read(&amp;row)
                if err != nil </span><span class="cov8" title="1">{
                        // Use errors.Is for proper EOF detection
                        if errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to read row: %w", err)</span>
                }
                <span class="cov8" title="1">rows = append(rows, row)</span>
        }

        <span class="cov8" title="1">return rows, nil</span>
}

// Schema returns the parquet file schema.
//
// The schema contains metadata about the columns, types, and structure
// of the parquet file.
func (r *Reader) Schema() *parquet.Schema <span class="cov8" title="1">{
        return r.pqFile.Schema()
}</span>

// Close closes the parquet reader and releases associated resources.
//
// Should be called when done reading to avoid resource leaks. It is safe
// to call Close multiple times.
func (r *Reader) Close() error <span class="cov8" title="1">{
        if r.file != nil </span><span class="cov8" title="1">{
                return r.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadMultipleFiles reads all rows from multiple parquet files matching a glob pattern.
//
// The pattern can include wildcards:
//   - * matches any sequence of non-separator characters
//   - ? matches any single non-separator character
//   - [range] matches any character in range
//   - {a,b} matches either a or b
//
// Examples:
//   - "data/*.parquet" - all parquet files in data directory
//   - "data/2024-*.parquet" - parquet files starting with 2024- in data directory
//   - "data/*/*.parquet" - parquet files in subdirectories of data
//
// Each row is tagged with a "_file" column containing the source file path.
// Returns an error if no files match the pattern or if any file fails to read.
func ReadMultipleFiles(pattern string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        // Check if pattern contains glob wildcards
        if !strings.ContainsAny(pattern, "*?[]{}") </span><span class="cov8" title="1">{
                // Not a glob pattern, read single file
                r, err := NewReader(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = r.Close() }</span>()

                <span class="cov8" title="1">rows, err := r.ReadAll()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Only tag rows with _file if reading multiple files (glob pattern)
                // Don't add _file for single file reads to avoid changing output shape
                // and potentially overwriting existing _file column

                <span class="cov8" title="1">return rows, nil</span>
        }

        // Expand glob pattern
        <span class="cov8" title="1">matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid glob pattern: %w", err)
        }</span>

        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no files match pattern: %s", pattern)
        }</span>

        // Limit number of files to prevent resource exhaustion
        <span class="cov8" title="1">const maxFiles = 1000
        if len(matches) &gt; maxFiles </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("glob pattern matched too many files (%d), maximum is %d", len(matches), maxFiles)
        }</span>

        // Read all matching files
        <span class="cov8" title="1">var allRows []map[string]interface{}
        for _, filePath := range matches </span><span class="cov8" title="1">{
                r, err := NewReader(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read %s: %w", filePath, err)
                }</span>

                <span class="cov8" title="1">rows, readErr := r.ReadAll()
                closeErr := r.Close()

                // Preserve the first error encountered
                if readErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read rows from %s: %w", filePath, readErr)
                }</span>
                <span class="cov8" title="1">if closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close %s: %w", filePath, closeErr)
                }</span>

                // Tag each row with the source file (only for multi-file reads)
                // Always set _file column to track source file
                <span class="cov8" title="1">for i := range rows </span><span class="cov8" title="1">{
                        rows[i]["_file"] = filePath
                }</span>

                <span class="cov8" title="1">allRows = append(allRows, rows...)</span>
        }

        <span class="cov8" title="1">return allRows, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package reader

import (
        "fmt"

        "github.com/parquet-go/parquet-go"
)

// SchemaInfo represents metadata about a single column in a Parquet file.
type SchemaInfo struct {
        Name         string `json:"name"`
        Type         string `json:"type"`
        PhysicalType string `json:"physical_type"`
        LogicalType  string `json:"logical_type"`
        Required     bool   `json:"required"`
        Optional     bool   `json:"optional"`
        Repeated     bool   `json:"repeated"`
}

// ExtractSchemaInfo extracts schema information from a Parquet file.
//
// Returns a slice of SchemaInfo containing metadata about each column including
// name, type information, and whether the field is required/optional/repeated.
//
// For nested types, field names use dot notation (e.g., "address.street").
func ExtractSchemaInfo(path string) ([]SchemaInfo, error) <span class="cov8" title="1">{
        reader, err := NewReader(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open parquet file: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = reader.Close() }</span>()

        <span class="cov8" title="1">schema := reader.Schema()
        fields := schema.Fields()

        var schemaInfos []SchemaInfo
        for _, field := range fields </span><span class="cov8" title="1">{
                schemaInfos = append(schemaInfos, extractFieldInfo(field, "")...)
        }</span>

        <span class="cov8" title="1">return schemaInfos, nil</span>
}

// extractFieldInfo recursively extracts schema information from a field.
// The prefix parameter is used to build dot-notation names for nested fields.
func extractFieldInfo(field parquet.Field, prefix string) []SchemaInfo <span class="cov8" title="1">{
        return extractFieldInfoWithParentRepeated(field, prefix, false)
}</span>

// extractFieldInfoWithParentRepeated recursively extracts schema information from a field,
// tracking whether any parent field is repeated.
func extractFieldInfoWithParentRepeated(field parquet.Field, prefix string, parentRepeated bool) []SchemaInfo <span class="cov8" title="1">{
        var infos []SchemaInfo

        // Build field name with prefix for nested fields
        fieldName := field.Name()
        if prefix != "" </span><span class="cov8" title="1">{
                fieldName = prefix + "." + fieldName
        }</span>

        // Check if this field or any parent is repeated
        <span class="cov8" title="1">isRepeated := parentRepeated || field.Repeated()

        // Check if field has child fields (nested type/group)
        childFields := field.Fields()
        if len(childFields) &gt; 0 </span><span class="cov8" title="1">{
                // This is a group/struct - recurse into child fields
                // Don't create a SchemaInfo for the group itself, only for leaf fields
                // Propagate repeated status to children
                for _, child := range childFields </span><span class="cov8" title="1">{
                        infos = append(infos, extractFieldInfoWithParentRepeated(child, fieldName, isRepeated)...)
                }</span>
                <span class="cov8" title="1">return infos</span>
        }

        // This is a leaf field - extract type information
        <span class="cov8" title="1">physicalType := getPhysicalType(field)
        logicalType := getLogicalType(field)
        userType := getUserFriendlyType(field)

        // Extract repetition information
        required := field.Required()
        optional := field.Optional()

        info := SchemaInfo{
                Name:         fieldName,
                Type:         userType,
                PhysicalType: physicalType,
                LogicalType:  logicalType,
                Required:     required,
                Optional:     optional,
                Repeated:     isRepeated,
        }

        infos = append(infos, info)

        return infos</span>
}

// getPhysicalType returns the physical type name of a Parquet field.
func getPhysicalType(field parquet.Field) string <span class="cov8" title="1">{
        if field.Type() == nil </span><span class="cov0" title="0">{
                return "GROUP"
        }</span>

        <span class="cov8" title="1">kind := field.Type().Kind()
        switch kind </span>{
        case parquet.Boolean:<span class="cov8" title="1">
                return "BOOLEAN"</span>
        case parquet.Int32:<span class="cov8" title="1">
                return "INT32"</span>
        case parquet.Int64:<span class="cov8" title="1">
                return "INT64"</span>
        case parquet.Int96:<span class="cov0" title="0">
                return "INT96"</span>
        case parquet.Float:<span class="cov8" title="1">
                return "FLOAT"</span>
        case parquet.Double:<span class="cov8" title="1">
                return "DOUBLE"</span>
        case parquet.ByteArray:<span class="cov8" title="1">
                return "BYTE_ARRAY"</span>
        case parquet.FixedLenByteArray:<span class="cov0" title="0">
                return "FIXED_LEN_BYTE_ARRAY"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// getLogicalType returns the logical type name of a Parquet field.
func getLogicalType(field parquet.Field) string <span class="cov8" title="1">{
        if field.Type() == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">logicalType := field.Type().LogicalType()
        if logicalType == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Use String() method which provides the logical type name
        <span class="cov8" title="1">return logicalType.String()</span>
}

// getUserFriendlyType returns a user-friendly type name for a Parquet field.
//
// This converts Parquet's physical and logical types into simpler, more
// recognizable type names for end users.
func getUserFriendlyType(field parquet.Field) string <span class="cov8" title="1">{
        if field.Type() == nil </span><span class="cov0" title="0">{
                return "GROUP"
        }</span>

        // Check logical type first for more specific typing
        <span class="cov8" title="1">logicalType := field.Type().LogicalType()
        if logicalType != nil </span><span class="cov8" title="1">{
                logicalTypeStr := logicalType.String()
                switch logicalTypeStr </span>{
                case "STRING", "UTF8":<span class="cov8" title="1">
                        return "STRING"</span>
                case "ENUM":<span class="cov0" title="0">
                        return "ENUM"</span>
                case "UUID":<span class="cov0" title="0">
                        return "UUID"</span>
                case "INT":<span class="cov0" title="0">
                        // For INT logical type, check the physical type
                        kind := field.Type().Kind()
                        switch kind </span>{
                        case parquet.Int32:<span class="cov0" title="0">
                                return "INT32"</span>
                        case parquet.Int64:<span class="cov0" title="0">
                                return "INT64"</span>
                        }
                case "DATE":<span class="cov0" title="0">
                        return "DATE"</span>
                case "TIME":<span class="cov0" title="0">
                        return "TIME"</span>
                case "TIMESTAMP":<span class="cov0" title="0">
                        return "TIMESTAMP"</span>
                case "DECIMAL":<span class="cov0" title="0">
                        return "DECIMAL"</span>
                case "JSON":<span class="cov0" title="0">
                        return "JSON"</span>
                case "BSON":<span class="cov0" title="0">
                        return "BSON"</span>
                }
        }

        // Fall back to physical type
        <span class="cov8" title="1">kind := field.Type().Kind()
        switch kind </span>{
        case parquet.Boolean:<span class="cov8" title="1">
                return "BOOLEAN"</span>
        case parquet.Int32:<span class="cov8" title="1">
                return "INT32"</span>
        case parquet.Int64:<span class="cov8" title="1">
                return "INT64"</span>
        case parquet.Int96:<span class="cov0" title="0">
                return "INT96"</span>
        case parquet.Float:<span class="cov8" title="1">
                return "FLOAT32"</span>
        case parquet.Double:<span class="cov8" title="1">
                return "FLOAT64"</span>
        case parquet.ByteArray:<span class="cov0" title="0">
                return "BYTE_ARRAY"</span>
        case parquet.FixedLenByteArray:<span class="cov0" title="0">
                return "FIXED_LEN_BYTE_ARRAY"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
